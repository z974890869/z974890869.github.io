<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>记录学习博客</title>
      <link href="/2021/06/13/ji-lu-xue-xi-bo-ke/"/>
      <url>/2021/06/13/ji-lu-xue-xi-bo-ke/</url>
      
        <content type="html"><![CDATA[<h1 id="简短介绍"><a href="#简短介绍" class="headerlink" title="简短介绍"></a>简短介绍</h1><p>如题</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>article title</title>
      <link href="/2021/06/12/article-title/"/>
      <url>/2021/06/12/article-title/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/06/12/hello-world/"/>
      <url>/2021/06/12/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new "My New Post"</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>BERT</title>
      <link href="/2021/05/30/bert/"/>
      <url>/2021/05/30/bert/</url>
      
        <content type="html"><![CDATA[<p>首先使用bert获取词向量bert-as-service</p><p>**1.**<strong>安装Bert-as-Service</strong></p><p><strong><em>pip install bert-serving-server &nbsp;# server</em>****<em>pip install bert-serving-client &nbsp;# client, independent of `bert-serving-server</em></strong></p><p>**2.**<strong>下载Bert预训练模型</strong></p><p><a href="https://github.com/hanxiao/bert-as-service"><strong>bert_uncased_L-12_H-768_A-12.zip</strong></a></p><p>**3.**<strong>开启服务</strong></p><ul><li>Anaconda 的cmd中启用<br>  <strong>_bert-serving-start -model_dir C:\Users\Administrator\Desktop\_<strong><strong><em>自然语言处理</em></strong></strong><em>\uncased_L-12_H-768_A-12 -num_worker=1</em></strong></li><li>  其中，-model_dir 是预训练模型的路径，-num_worker 是线程数，表示同时可以处理多少个并发请求</li></ul><p>**4.**<strong>加载句向量</strong></p><ul><li>  转到pycharm，创建一个py文件然后输入如下代码，如果产生了向量矩阵则说明配置成功</li></ul><p>from bert_serving.client import BertClient</p><p>bc = BertClient()</p><p>vec = bc.encode([“yan”, “low”]) print(vec)</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>由于使用bert的预训练模型768维的输出不可改变，我们可以改变上述三个模型中LSTM，**<em>self</em><strong><strong><em>.lstm = nn.LSTM(</em></strong></strong><em>input_size</em>****<em>=config.words_dim, # 768</em>**</p><p>用BERT替换gloVe 300</p><p>使用GloVe部分</p><p>if os.path.isfile(args.vector_cache): # vector_cache(存储器) = “data/sq_glove300d.pt”<br>    # stoi 序号对应的词{‘,’: 0, ‘.’: 1, ‘the’: 2，…，’sábato’: 52282} vector = torch.Size([52283, 300]) dim = 300<br>    stoi, vectors, dim = torch.load(args.vector_cache)<br>    TEXT.vocab.vectors = torch.Tensor(len(TEXT.vocab), dim) # 矩阵<br>    for i, token in enumerate(TEXT.vocab.itos): # itos token<br>        wv_index = stoi.get(token, None) # if TEXT in glove300<br>        if wv_index is not None: # 则 token to vector like the weights (转换因子)<br>            TEXT.vocab.vectors[i] = vectors[wv_index]<br>            match_embedding += 1<br>        else: #随机生成 (-0.25,0.25)之间数值 dim个float<br>            TEXT.vocab.vectors[i] = torch.FloatTensor(dim).uniform_(-0.25, 0.25) # _表示修改本身数据<br>else: print(“Error: Need word embedding pt file”)<br>    exit(1)</p><p>替换后</p><p>bc = BertClient() if bc: for i, token in enumerate(TEXT.vocab.itos):  # itos token<br>        if bc.encode(token.split()).any():<br>            TEXT.vocab.vectors[i] = torch.tensor(bc.encode(token.split())) #list 会分成字母<br>            match_embedding += 1<br>        else: # 随机生成 (-0.25,0.25)之间数值 dim个float<br>            TEXT.vocab.vectors[i] = torch.FloatTensor(dim).uniform_(-0.25, 0.25)  # _表示修改本身数据<br>else: print(“Error: Need word embedding pt file”)<br>    exit(1)</p><p>if os.path.isfile(args.vector_cache): # vector_cache(存储器) = “data/sq_glove300d.pt”  </p><h1 id="stoi-序号对应的词-‘-’-0-‘-’-1-‘the’-2，…，’sabato’-52282-vector-torch-Size-52283-300-dim-300"><a href="#stoi-序号对应的词-‘-’-0-‘-’-1-‘the’-2，…，’sabato’-52282-vector-torch-Size-52283-300-dim-300" class="headerlink" title="stoi 序号对应的词{‘,’: 0, ‘.’: 1, ‘the’: 2，…，’sábato’: 52282} vector = torch.Size([52283, 300]) dim = 300"></a>stoi 序号对应的词{‘,’: 0, ‘.’: 1, ‘the’: 2，…，’sábato’: 52282} vector = torch.Size([52283, 300]) dim = 300</h1><p>stoi, vectors, dim = torch.load(args.vector_cache)<br>    TEXT.vocab.vectors = torch.Tensor(len(TEXT.vocab), dim) # 矩阵<br>for i, token in enumerate(TEXT.vocab.itos): # itos token<br>wv_index = stoi.get(token, None)<br>        # if TEXT in glove300<br>if wv_index is not None:<br>            # 则 token to vector like the weights (转换因子)<br>TEXT.vocab.vectors[i] = vectors[wv_index]<br>            match_embedding += 1<br>else:<br>            #随机生成 (-0.25,0.25)之间数值 dim个float<br>TEXT.vocab.vectors[i] = torch.FloatTensor(dim).uniform_(-0.25, 0.25) # _表示修改本身数据<br>else:<br>    print(“Error: Need word embedding pt file”)<br>    exit(1)</p><!-- more -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Knowledge Graph Embedding Based Question Answering</title>
      <link href="/2021/05/27/knowledge-graph-embedding-based-question-answering/"/>
      <url>/2021/05/27/knowledge-graph-embedding-based-question-answering/</url>
      
        <content type="html"><![CDATA[<p><strong>记录下学习过NLP，就是个作业草稿</strong></p><p>本次选取论文[1]《Knowledge Graph Embedding Based Question Answering》</p><p>论文代码网址：</p><p><a href="https://github.com/xhuang31/KEQA/_WSDM19">https://github.com/xhuang31/KEQA\_WSDM19</a></p><p>概念介绍</p><p>Simple Question：If a natural language question only involves a single head entity and a single predicate in the knowledge graph, and takes their tail entity/entities as the answer, then this question is referred as a simple question&nbsp; (只有一个主语，一个谓语的问题)</p><p>下列概念均来自[2] ：基于知识图谱的问答系统研究与应用</p><p><strong>知识图谱</strong>：是一种新兴的数据存储方式，主要特征为使用 RDF 三元组格式进行存储。相比于文本知识，知识图谱具有更丰富的语义表达、更精确的数据内容、更高效的检索方式。</p><p>实体识别：是指从非结构化的文本中识别出具有特定意义或者指代性强的实体，例如人名、地名、组织机构名、日期时间、专有名词等。</p><p><strong>实体连接</strong>：通过实体识别模块识别出问句中的实体信息后，需要将识别出的实体信息正确地指向到知识图谱中目标实体上去。一般实体链接系统会分别采用候选实体生成和实体消歧两个模块解决。候选实体生成模块的输入是上一节实体识别模块识别出的实体提及（Entity Mention），输出是知识图谱中与该提及相关的实体。该过程要求系统尽可能多的返回实体，提升系统召回率。候选实体生成模块通常采用词表匹配的方法。构造出的词表通常包含同义词信息、缩写全称映射信息与别名信息等。实体消歧模块的输入为候选实体生成模块产生的候选实体集和用户输入问句，输出是候选实体集中与问句最相关的实体，或者是经过排序后的候选实体集。</p><p><strong>关系检测（Relation Detection）</strong>：是将用户输入映射到知识图谱某一关系的过程。通过实体链接步骤后，我们可以将问答范围缩小至该实体所在的知识图谱局部范围内。使用关系检测技术确定用户所提及的关系后，结合实体链接搜索出的实体，构造出（实体，关系）对，就可以完成单关系简单问题的回答。</p><p>评价指标：</p><p><strong>精确度（Precision）</strong>：代表了系统正确识别出的实体占全部识别出的实体中的比例。</p><p>**召回率(Recall)**：指正确识别出的实体占数据集中全部实体的比例。</p><p>仅使用精确度和召回率无法全面的评价系统的好坏，使用 F-score 来平衡这两个指标的结果。</p><p>这里简单介绍以下<strong>词向量</strong>：想要详细了解可以参考《自然语言处理实战》Manning出版社的。</p><p><img src="https://img2020.cnblogs.com/blog/2092141/202105/2092141-20210527194637780-645823523.png"></p><p>词向量可以看作一个权重列表，列表中每个权重都对应这个词在某个特定维度的含义。比如玛丽居里可以由五个维度(和平，有人情味，动物，概念化，女性)表示</p><p>WordVector[‘Marie_Curie’] = [-0.46(placeness); 0.35(peopleness); 0.17(animalness);-0.32(conceptness); 0.26(femaleness)]</p><p>词向量可以做数学运算，再把得到的结果向量转成词</p><h1 id="数据集介绍"><a href="#数据集介绍" class="headerlink" title="数据集介绍"></a>数据集介绍</h1><p>数据集使用 Freebase 的子集 FB2M和FB5M作为支撑知识图谱，问句总数达到了 10 万规模。FB2M 共包含 6701个关系类别。</p><p>相比于其他的数据集，Simple Questions 一定程度上弥补了训练集无法覆盖知识图谱的问题。</p><p> <img src="https://img2020.cnblogs.com/blog/2092141/202105/2092141-20210527194726612-719447068.png"> </p><p>SimpleQuestions 数据集使用实体编号来代替实体名称 “/location/location/time_zones”用于表示知识图谱中的关系名称。</p><h1 id="大纲图"><a href="#大纲图" class="headerlink" title="大纲图"></a>大纲图</h1><p> <img src="https://img2020.cnblogs.com/blog/2092141/202105/2092141-20210527194738344-1224389446.png"> </p><p>从图中可以看出首先将知识图谱(KG)嵌入成两个低维vector, Predicates(谓语)，Entities(名词)，</p><p>再根据数据集训练Predicate and Head Entity Model,详细的说这两个model的input都是question，输出分别为<img src="https://img2020.cnblogs.com/blog/2092141/202105/2092141-20210527194900783-1258182983.png"><img src="https://img2020.cnblogs.com/blog/2092141/202105/2092141-20210527194916011-755921665.png"></p><p>通过给定的函数计算<img src="https://img2020.cnblogs.com/blog/2092141/202105/2092141-20210527194924008-432646579.png"></p><p>，最后通过精心设计的评价函数，得到最符合fact作为answer。</p><h2 id="Knowledge-Graph-Embedding"><a href="#Knowledge-Graph-Embedding" class="headerlink" title="Knowledge Graph Embedding"></a>Knowledge Graph Embedding</h2><p>嵌入部分是用低维向量尽可能的表示原始数据。我们学习样本为使用TransE和TrainsR训练得到的知识图谱的嵌入空间。<br>下载网址：_<a href="https://www.dropbox.com/s/o5hd8lnr5c0l6hj/KGembed.zip">https://www.dropbox.com/s/o5hd8lnr5c0l6hj/KGembed.zip</a>_<em>。</em></p><p>里面的 entities_emb.bin, predicates_emb.bin是我们需要学习的嵌入空间</p><h2 id="Predicate-and-Head-Entity-Learning-Models"><a href="#Predicate-and-Head-Entity-Learning-Models" class="headerlink" title="Predicate and Head Entity Learning Models"></a>Predicate and Head Entity Learning Models</h2><p>这是模型双向LSTM和Attention , LSTM 是为了考虑一个question中词的顺序，Attention考虑了每个词对于理解这个问题的重要程度不同。</p><p> <img src="https://img2020.cnblogs.com/blog/2092141/202105/2092141-20210527194942105-439915938.png"> </p><p>从上图可以看出首先将问题嵌入成带顺序的词向量&nbsp;,j = 1-L, L为问题的单词词数量。这里应用的嵌入模型是GloVe</p><p>args.vector_cache = “data/sq_glove300d.pt” </p><p>if os.path.isfile(args.vector_cache):# 如果glove文件存在</p><pre><code># stoi : \[3 'the': 2，...，'sábato': 52282\]  词和对应的序号# vector = torch.Size(\[52283, 300\]) 每个词的向量表示 # dim = 300 用dim个元素表示一个词</code></pre><p> stoi, vectors, words_dim = torch.load(args.vector_cache) # 加载文件</p><p>else: # 如果文件不存在 报错并退出</p><pre><code>print("Error: Need word embedding pt file")exit(1)</code></pre><p>match_embedding = 0 # 嵌入词的个数<br> TEXT.vocab.vectors = torch.Tensor(len(TEXT.vocab), words_dim) # 定义待数据集，申请内存空间</p><p>for i, token in enumerate(TEXT.vocab.itos): # 读取数据集中的词<br> wv_index = stoi.get(token, None) # 如果数据集中的词在GloVe中存在，则取下标</p><pre><code>if wv\_index is not None: # 如果wv\_index存在    # 将使用GloVe中的向量替换该词，并储存在待训练数据集中</code></pre><p> TEXT.vocab.vectors[i] = vectors[wv_index]</p><pre><code>    match\_embedding += 1 # 能在GloVe中找到的词个数+1else: # 使用随机生成的向量代替在GloVe找不到对应的词</code></pre><p> TEXT.vocab.vectors[i] = torch.FloatTensor(words_dim).uniform_(-0.25, 0.25)</p><p>为了在模型中应用将词向量矩阵移动到模型中**<em>model.embed.weight.data.copy_(TEXT.vocab.vectors)</em>**，</p><p>并且将文本变为，</p><p>x = self.embed(text)</p><p>嵌入后的&nbsp;通过双向LSTM得到&nbsp;= [正向:反向]</p><p>outputs, (ht, ct) = self.lstm(x) # 通过双向LSTM的hj<br>其中self.lstm = nn.LSTM(input_size=config.words_dim,</p><pre><code>                   hidden\_size\=config.hidden\_size,                   num\_layers\=config.num\_layer,                   dropout\=config.rnn\_dropout,                   bidirectional\=True)</code></pre><p>再经过注意力机制</p><p><img src="https://img2020.cnblogs.com/blog/2092141/202105/2092141-20210527195014809-1370897664.png"></p><p>注意力机制由两部分组成，非线性部分 </p><p>x = x.view(-1, words_dim) # 为了连接output进行view改变形状<br> attn_weights = F.softmax(self.attn(torch.cat((x, outputs), 1)), dim=0) # alpha = softmax(q)<br>这里的self.attn = nn.Sequential(</p><p>   nn.Linear(config.hidden_size * 2 + config.words_dim, config.hidden_size), # W’[x:h] + bq<br> self.nonlinear, # q = tanh(W’[x:h] + bq)<br> nn.Linear(config.hidden_size, 1) #变成1维输出为了softmax输入<br> )</p><p>和softmax分类部分 </p><p>attn_applied = torch.bmm(torch.diag(attn_weights[:, 0]).unsqueeze(0), outputs.unsqueeze(0)) # alpha * h<br> outputs = torch.cat((x, attn_applied.squeeze(0)), 1) # sj = [x:alpha * h]</p><p>分数最后由各个数据流经过注意力的均值预测谓语</p><p><img src="https://img2020.cnblogs.com/blog/2092141/202105/2092141-20210527195025590-1779421976.png"></p><p>scores = nn.functional.normalize(torch.mean(tags, dim=0), dim=1) # p^ = mean(r)</p><p>将预测值与实际嵌入谓语之间使用MSE损失函数**<em>criterion = nn.MSELoss()</em>**差值反向传播训练模型。</p><p>loss = criterion(model(batch), predicates_emb[batch.mid, :])</p><p>loss.backward() #反向传播</p><h1 id="clip-the-gradient：设置梯度阈值，防止梯度爆炸"><a href="#clip-the-gradient：设置梯度阈值，防止梯度爆炸" class="headerlink" title="clip the gradient：设置梯度阈值，防止梯度爆炸"></a>clip the gradient：设置梯度阈值，防止梯度爆炸</h1><p> torch.nn.utils.clip_grad_norm_(model.parameters(), args.clip_gradient)</p><p>optimizer.step() # 梯度优化</p><p>经过训练多次模型的准确度不在提升，则此时为最好的模型：</p><h1 id="update-model"><a href="#update-model" class="headerlink" title="update model"></a>update model</h1><p>if curr_accu &gt; best_accu:  # 如果精确度提升<br> best_accu = curr_accu # 此时精确度为最好的精确度<br> best_loss = total_loss # 记录loss<br> iters_not_improved = 0 # 模型不在提升的次数刷新为0</p><pre><code># save model, delete previous 'best\_snapshot' files</code></pre><p> torch.save(model, os.path.join(args.output, args.best_prefix + ‘_best_model.pt’)) else: #如果精确度没有提升<br> iters_not_improved += 1 # 模型不提升次数+1</p><pre><code>if iters\_not\_improved &gt; patience: # 如果不提升次数达到设置次数</code></pre><p> early_stop = True # 停止训练模型</p><pre><code>    break</code></pre><p><img src="https://img2020.cnblogs.com/blog/2092141/202105/2092141-20210527200301117-1866966072.png"></p><h1 id="Head-Entity-Detection-Model"><a href="#Head-Entity-Detection-Model" class="headerlink" title="Head Entity Detection Model"></a>Head Entity Detection Model</h1><p>由于&nbsp;对应许多head entities,所以我们需要减少候选数量，这就是Head Entity Detection Model的作用。</p><p> <img src="https://img2020.cnblogs.com/blog/2092141/202105/2092141-20210527195050324-274470610.png"> </p><p>这是个简单的双向LSTM+softmax分类模型，这是模型是为了将所有的token(question 的分词)分为Entity Name Token （label = “I”）or Non Entity Name Token(label = “O”)即，该词是entity or non entity。</p><p>我们先介绍两个数据文件**”annotated_fb_data_train” and ‘names.trimmed.txt’**<strong>。</strong></p><p>**”annotated_fb_data_train”**<strong>是</strong>_SimpleQuestions_数据集中data含有的文件每行含有四部分</p><p>我们忽略其中的网址，它代表freebase数据集。</p><p>我们把这四部分分为item[0],item[1],item[2],item[3]</p><p>item[0] 是主语；item[1] 是谓语；item[2] 是宾语；item[3] 是问题</p><p>其中主语和宾语是由他们对应的编号代替，例如：drum的编号为m.0f9rv4n</p><p>**’names.trimmed.txt’**是经过处理的数据，每一行是实体和他们对应的实体编号， 例如第一行</p><p><strong><em>m.0f8vjgd&nbsp;&nbsp;&nbsp;&nbsp; skyshaper</em></strong></p><p>关于**’names.trimmed.txt’**经过怎样处理我们先不谈，现在只需要知道是处理SimpleQuestions 数据集中FB5M.names.txt文件得到。</p><p>首先将**’names.trimmed.txt’**读入到程序中，并且储存为字典格式，方便实体和实体编号之间的联系</p><p>names_map = [3]</p><p>with open(os.path.join(args.output, ‘names.trimmed.txt’), ‘r’) as f: for i, line in enumerate(f):</p><pre><code>     items \= line.strip().split("\\t")</code></pre><p>entity = items[0]</p><p>literal = items[1].strip() if names_map.get(entity) is None: # 如果entity在dict中还没有<br> names_map[entity] = [(literal)] # 创建字典[2]</p><p>else: #如果已经存在，添加value (‘m.0f9x06p’, [‘long , long journey’])<br> names_map[entity].append(literal)</p><p>该行问题中主语对应的实体名称保存到 <strong><em>cand_entity_names</em></strong></p><p>if names_map.get(subject) is None:</p><pre><code>cand\_entity\_names \= None else: # if subject in names\_map to can\_entity\_names = names</code></pre><p> cand_entity_names = names_map[subject]<br>该行问题中没有主语的情况，对应名称用’’填充，并且label = O*num of tokens</p><p>tokens = sent.split() # 将question分词<br> label = [“O”] * len(tokens) # 先标记全不是entity<br> text_attention_indices = None # 判断question中是否有subject<br> exact_match = False # 是否精确匹配</p><p>if text_candidate is None or len(text_candidate) == 0:# 如果该行没有主语，label全为O</p><pre><code>return '', ' '.join(label), exact\_match</code></pre><p>如果该行问题中有主语，则将主语在该问题中对应位置label设置为“I”</p><p>text_attention_indices = get_indices(tokens, text.split()) # get_indices 返回text在tokens中的下标范围<br>if text_attention_indices != None:</p><pre><code>exact\_match \= True for i in text\_attention\_indices:    label\[i\] \= 'I'</code></pre><p>如果该行问题中有主语，但是该主语在数据集中没有找到，则使用fuzzy找出最相似的一个主语代替，如果找不到，则对应名称用**_’’_<strong>填充，并且</strong><em>label = O*num of tokens</em>**</p><p>else: # if no match</p><pre><code>try: # process.extractOne 提取匹配度最大的结果</code></pre><p> v, score = process.extractOne(sent, text_candidate, scorer=fuzz.partial_ratio) except: # if no find</p><pre><code>    print("Extraction Error with FuzzyWuzzy : \[2\] || \[2\]".format(sent, text\_candidate)) return '', ' '.join(label), exact\_match</code></pre><p>这样完成了标签的标记。</p><p>为了消除噪音，删除不存在主语的问题，即删除掉全是O的question，并保存在dete_train.txt中</p><p>outfile = open(os.path.join(args.output, ‘dete_train.txt’), ‘w’) for line in open(os.path.join(args.output, ‘train.txt’), ‘r’):</p><pre><code>items \= line.strip().split("\\t")tokens \= items\[6\].split() #items\[6\] = train.label# 因为question首字母是疑问词(what how where等)一定不是entityif any(token != tokens\[0\] for token in tokens): # (False False False False True False)</code></pre><p> outfile.write(“{}\t{}\n”.format(items[5], items[6]))</p><p>outfile.close()</p><p>到这里就完成对数据集的处理。</p><p>此时的模型input是question，output是该问题中所有主语的位置为“I“，其他为”O“的Label。</p><h1 id="Joint-Search-on-Embedding-Spaces"><a href="#Joint-Search-on-Embedding-Spaces" class="headerlink" title="Joint Search on Embedding Spaces"></a>Joint Search on Embedding Spaces</h1><p>到目前为止，我们已经对一个问题进行了预测谓词,主语和question中分词的标签，即（,label）。我们的目标是找出最匹配的fact（一个回答由主语谓语宾语组成）。</p><p>我们把Label为“I“对应的主语叫做candidate head entities(候选主语)，把含有候选主语的fact叫做candidate fact（候选语料）。由于主语和谓语相同的语料不一定只有一个，为了选择出最符合的一个fact。该论文中提出了Joint distance metric，利用知识图谱的特点:<img src="https://img2020.cnblogs.com/blog/2092141/202105/2092141-20210527195152691-889583595.png"></p><p> <img src="https://img2020.cnblogs.com/blog/2092141/202105/2092141-20210527195114934-137707424.png"> </p><p>前两项代表预测主语和谓语的偏差，第三项代表公式计算出与实际宾语的偏差，后两项表示Label是否正确标记了主语和非主语。可以看出该函数就是对上述三个模型的损失函数的最小值。也就是最符合的fact。</p><p>我们来看一下完成的算法流程：</p><p> <img src="https://img2020.cnblogs.com/blog/2092141/202105/2092141-20210527195214506-1758985307.png"> </p><p>前1-9行可以同时进行训练，以减少时间。10-12行对一个new dataset应用之前的模型进行训练，得到&nbsp;<img src="https://img2020.cnblogs.com/blog/2092141/202105/2092141-20210527195254297-1600655122.png"> </p><p>：</p><h1 id="load-pred-model"><a href="#load-pred-model" class="headerlink" title="load pred model"></a>load pred model</h1><p>model = torch.load(args.pred_model, map_location=lambda storage, loc: storage.cuda(args.gpu)) # 加载Pred_model到GPU<br>scores = model(data_batch).cpu().data.numpy() # 预测并保存为numpy类型，为了进行计算<br>for i in range(batch_size):</p><pre><code>pred\_emb\[baseidx \+ i\] = scores\[i\] # 保存到pred\_emb</code></pre><p>baseidx = baseidx + batch_size # 下一次小批次</p><h1 id="load-dete-model"><a href="#load-dete-model" class="headerlink" title="load dete model"></a>load dete model</h1><p>model = torch.load(args.dete_model, map_location=lambda storage, loc:<br>storage.cuda(args.gpu)) # load detemodel to GPU<br>answer = torch.max(model(data_batch), 1)[1].view(data_batch.ed.size()) # 预测并转变成与torchtext处理后的数据集相同大小<br>answer = np.transpose(answer.cpu().data.numpy()) # 转置<br>dete_result.extend(answer) # 存放在dete_result列表</p><h1 id="load-entity-model"><a href="#load-entity-model" class="headerlink" title="load entity model"></a>load entity model</h1><p>model = torch.load(args.entity_model, map_location=lambda storage, loc: storage.cuda(args.gpu))<br>scores = model(data_batch).cpu().data.numpy() for i in range(batch_size): # 变成一行，每个元素是list(scores[i])<br> head_emb[baseidx + i] = scores[i] # 保存到head_emb<br> baseidx = baseidx + batch_size # 下一次小批次</p><p>13-14行是HED模型结果上找出最优fact</p><p> 1 beta1, beta2, beta3,bete4 = .39, .43, .003, .017<br> 2<br> 3 # head_mid_idx = {匹配的编号：name} + {不匹配编号：None}<br> 4<br> 5 for i, head_ids in enumerate(head_mid_idx): # 基于HEDmodel的结果寻找符合的fact集合C<br> 6<br> 7     if i % 1000 == 1: # 处理进度<br> 8<br> 9         print(‘progress:  {}’.format(i / total_num), end=’\r’) 10<br>11     answers = [] 12<br>13     for (head_id, name) in head_ids: # dict遍历</p><p><strong><em><img src="https://img2020.cnblogs.com/blog/2092141/202105/2092141-20210527195323443-984576088.png"></em></strong></p><p> <strong><em>#</em></strong> <strong><em>公式中的第二项</em></strong> </p><p>entity_score = np.sqrt(np.sum(np.power(entities_emb[mid_dic[head_id]] - head_emb[i], 2)))</p><p><strong><em><img src="https://img2020.cnblogs.com/blog/2092141/202105/2092141-20210527195337638-806945204.png"></em></strong></p><p> <strong><em>#</em></strong> <strong><em>第四项</em></strong> </p><p> name_score = -beta3 * fuzz.ratio(name, dete_tokens_list[i]) # dete_tokens_list = 问题的文字形式</p><pre><code>    if (head\_id, name) in tuple\_topic: # 如果预测的主语是宾语，则减少分数</code></pre><p> name_score -= .18</p><pre><code>    if reach\_dic.get(head\_id) is not None: # 排除掉HEDnon的主语        for pred\_id in reach\_dic\[head\_id\]:  # reach\_dic\[head\_id\] = pred\_id</code></pre><p><strong><em><img src="https://img2020.cnblogs.com/blog/2092141/202105/2092141-20210527195345266-1747827227.png"></em></strong></p><p> <strong><em>#</em>****<em>最后一项</em></strong> <strong><em>filter_q =</em></strong> <strong><em>数据集中从问题中提取的谓语（真实值）由于</em>****<em>pred_id</em></strong> <strong><em>就是</em><strong><strong><em>Entitynon</em></strong></strong><em>部分</em></strong> </p><p> pred_names = fuzz.ratio(pre_num_dic[pred_id].replace(‘.’, ‘ ‘).replace(‘_‘, ‘ ‘), filter_q[i]) # pre_num_dic = {pred_id:pred}</p><p><strong>_<br><img src="https://img2020.cnblogs.com/blog/2092141/202105/2092141-20210527195355171-459928191.png">_</strong></p><p> <strong><em>#</em></strong> <strong><em>公式中的第一项</em></strong> </p><p>  pred_score = np.sqrt(np.sum(np.power(predicates_emb[pred_id] - pred_emb[i], 2)))</p><p>**_<img src="https://img2020.cnblogs.com/blog/2092141/202105/2092141-20210527195411953-1433789877.png">  </p><p>_**</p><p> 1 tai_score = np.sqrt(np.sum( # 第三项<br> 2<br> 3                     np.power(predicates_emb[pred_id] + entities_emb[mid_dic[head_id]] - head_emb[i] - pred_emb[i], 2)))<br> 4<br> 5                 joint_distance_metric = pred_score +  beta1 * entity_score + beta2 * tai_score + name_score - bete4 *pred_names<br> 6<br> 7                 answers.append((head_id, pred_id, joint_distance_metric ))<br> 8<br> 9     if answers: # 如果找到fact<br>10<br>11         answers.sort(key=lambda x: x[2]) # 以joint_distance_metric分数进行排序<br>12<br>13         learned_head[i] = answers[0][0] # 取分数最高的fact的主语<br>14<br>15         learned_pred[i] = answers[0][1] # 取分数最高的fact的谓语<br>16<br>17         learned_fact[‘ ‘.join([learned_head[i], pre_num_dic[learned_pred[i]]])] = i # 最合适的fact = head + pred</p><p>这里的**<em>head_mid_idx = {匹配的编号：name} + {不匹配编号：None}</em><strong>是由HED模型结果dete_result，处理得到，所以是</strong><em>Find the candidate fact set C from G, based on HEDentity;</em>**</p><p>[1] HUANG X, ZHANG J, LI D, 等. Knowledge Graph Embedding Based Question Answering[A]. Proceedings of the Twelfth ACM International Conference on Web Search and Data Mining[C]. 2019. 105-113.</p><p>[2] 乔振浩. 基于知识图谱的问答系统研究与应用[D]. 哈尔滨工业大学, 2020.</p><p>[3] 霍布森·莱恩、科尔·霍华德、汉纳斯·马克斯·哈普克、史亮、鲁骁、唐可欣、王斌. 《自然语言处理实战》[J]. 中文信息学报, 2020, v.34(10): 117-117.</p><!-- more -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Implementations</title>
      <link href="/2020/12/19/implementations/"/>
      <url>/2020/12/19/implementations/</url>
      
        <content type="html"><![CDATA[<p> 1 #include 2 #include&lt;string&gt;<br> 3 //Provision_26 : Postone variable definitions as long as possible<br> 4<br> 5 //如果定义还没用就抛出异常 需要：构造+析构<br> 6<br> 7 void AB() { 8     class S 9     {<br> 10     public:<br> 11         S() = default;<br> 12         S(const int&amp; _i) :i(_i) {} 13     private:<br> 14         std::string s; 15         int i; 16     };<br> 17     int f(int i); 18     auto n = 100;<br> 19     S A;//method A: 1 构造 + 1 析构 + n 赋值<br> 20     for (int i = 0;i &lt; n;++i)<br> 21     {<br> 22         A = S(i); 23     }<br> 24     //method B : n 构造 + n 析构<br> 25     for (int i = 0;i &lt; n;++i)<br> 26     {<br> 27         S B(f(i));<br> 28     }<br> 29 }<br> 30 //当 构造 + 析构  &lt; 赋值 ：using B 变量A作用域也大<br> 31<br> 32 //Provision_27 Minimize casting<br> 33 //避免使用 dynamic_cast<br> 34<br> 35 //问题：只有 base point 要执行 derived class member function<br> 36 //解决： 在base class 中  virtual derived member function<br> 37<br> 38 class Window 39 {<br> 40 public:<br> 41     virtual void blink() = 0;//闪烁<br> 42 };<br> 43 class SpecialWindow :public Window 44 {<br> 45 public:<br> 46     virtual void blink() override<br> 47     {<br> 48         //….<br> 49     };<br> 50 };<br> 51<br> 52 //Provision_31: Minimize compilation dependencies between files<br> 53 //问题：class private成员往往依赖头文件(#include”Tree_Note.h”) 若头文件修改则导致所有依赖该头文件的实现(Tree_Note type)都重新编译<br> 54 //解决1 ：(Handle classes)point to imolementation :将对象实现细节隐藏于一个指针背后<br> 55<br> 56 //Person.h<br> 57<br> 58 #pragma once<br> 59 #include&lt;string&gt;<br> 60 #include 61<br> 62 class PersonImpl; 63 class Date; 64 class Address; 65<br> 66 class Person 67 {<br> 68 public:<br> 69     Person(const std::string&amp; name, const Date&amp; birthday, const Address&amp; addr); 70     std::string name() const;<br> 71     std::string birthday() const;<br> 72     std::string address() const;<br> 73 private:<br> 74     std::shared_ptr pImpl; 75 };<br> 76<br> 77 //Person.cpp<br> 78<br> 79 #include”person.h”<br> 80 #include”PersonImpl.h”<br> 81<br> 82 Person::Person(const std::string&amp; name, const Date&amp; birthday, const Address&amp; addr) 83     :pImpl(std::make_shared(name, birthday, addr)) {}<br> 84 std::string Person::name() const<br> 85 {<br> 86     return pImpl-&gt;name();<br> 87 }<br> 88 std::string Person::birthday() const<br> 89 {<br> 90     return pImpl-&gt;birthday();<br> 91 }<br> 92 std::string Person::address() const<br> 93 {<br> 94     return pImpl-&gt;address();<br> 95 }<br> 96<br> 97 //PersonImpl.h<br> 98<br> 99 #pragma once<br>100 #include&lt;string&gt;<br>101 #include”Date.h”<br>102 #include”Address.h”<br>103 class PersonImpl 104 { 105 public: 106     PersonImpl(const std::string&amp; name, const Date&amp; birthday, const Address&amp; addr) 107 :theName(name), theBirthday(birthday), theAddress(addr) {} 108     std::string name() const; 109     std::string birthday() const; 110     std::string address() const; 111 private: 112     std::string theName; 113 Date theBirthday; 114 Address theAddress; 115 }; 116<br>117<br>118 //PersonImpl.cpp<br>119<br>120 #include”PersonImpl.h”<br>121 std::string<br>122 PersonImpl::name() const { return theName; } 123 std::string<br>124 PersonImpl::birthday() const { return theBirthday.date(); } 125 std::string<br>126 PersonImpl::address() const { return theAddress.addr(); } 127<br>128<br>129 //解决2: (Interface class)abstract base 接口在Person 细节在class RealPerson :public Person private 130 //使用：auto pp(Person::create(name,birthday,addr)) 131<br>132 //person.h<br>133<br>134 class Person 135 { 136 public: 137     virtual ~Person() {} 138     virtual std::string name() const = 0; 139     virtual std::string birthday() const = 0; 140     virtual std::string address() const =0 ; 141<br>142     static std::shared_ptr create(const std::string&amp; name, const Date&amp; birthday, const Address&amp; addr); 143 }; 144<br>145<br>146 //person,cpp<br>147<br>148 #include”Person.h”<br>149 #include”RealPerson.h”<br>150 std::shared_ptr 151 Person::create(const std::string&amp; name, const Date&amp; birthday, const Address&amp; addr) 152 { 153     return std::make_shared(RealPerson(name, birthday, addr)); 154 } 155<br>156<br>157 //RealPerson<br>158<br>159 #pragma once<br>160 #include”person.h”<br>161 #include&lt;string&gt;<br>162 #include”Date.h”<br>163 #include”Address.h”<br>164<br>165 class RealPerson :public Person 166 { 167 public: 168     RealPerson(const std::string&amp; name, const Date&amp; birthday, const Address&amp; addr) 169 :theName(name), theBirthday(birthday), theAddress(addr) {} 170     virtual ~RealPerson() {} 171     std::string name() const override; 172     std::string birthday() const override; 173     std::string address() const override; 174 private: 175     std::string theName; 176 Date theBirthday; 177 Address theAddress; 178 }; 179<br>180<br>181 //RealPerson.cpp<br>182<br>183 #include”PersonImpl.h”<br>184 std::string<br>185 PersonImpl::name() const { return theName; } 186 std::string<br>187 PersonImpl::birthday() const { return theBirthday.date(); } 188 std::string<br>189 PersonImpl::address() const { return theAddress.addr(); }</p><!-- more -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Designs and Declarations</title>
      <link href="/2020/12/19/designs-and-declarations/"/>
      <url>/2020/12/19/designs-and-declarations/</url>
      
        <content type="html"><![CDATA[<p> 1 //provision_21: Don’t try to return a reference when you must return an object<br> 2 //static :不能比较<br> 3 #include 4 class Rational 5 {<br> 6     friend const Rational&amp;<br> 7         operator*(const Rational&amp; lhs, const Rational&amp; rhs); 8     friend bool<br> 9         operator==(const Rational&amp; lhs, const Rational&amp; rhs); 10 public:<br> 11     Rational(int _n = 0, int _d = 1) :n(_n), d(_d) {}<br> 12 private:<br> 13     int n,d; 14 };<br> 15<br> 16 const Rational&amp;<br> 17 operator*(const Rational&amp; lhs, const Rational&amp; rhs) 18 {<br> 19     static Rational result; //只在第一个作用<br> 20     result.n = lhs.n * rhs.n; 21     result.d = lhs.d * rhs.d; 22     return result; 23 }<br> 24 bool operator==(const Rational&amp; lhs, const Rational&amp; rhs) 25 {<br> 26     return ((lhs.n == rhs.n) &amp;&amp; (lhs.d == rhs.d)) ? true : false;<br> 27 }<br> 28 int main() 29 {<br> 30     Rational a, b(1,2), c(3,4), d(5,6);<br> 31     if ((a * b) == (c * d)) //返回的都是 staic result 的引用： if( static Rational&amp; == static Rational&amp;)<br> 32         //换句话说：在operator==(l,r) 时比较的都是最后一次operator*(a,b)的result 而(c*d)存放的值被(a*b)替换<br> 33         std::cout &lt;&lt; “always true” &lt;&lt; std::endl; 34     return 0;<br> 35 }<br> 36<br> 37 //Provision_24 Declare non-member functions when type conversions should apply to all parameters<br> 38 //当不涉及template 时，如果可以避免friend 函数就该避免<br> 39 class Ration 40 {<br> 41 public:<br> 42     Ration(int _n = 0, int _d = 1) :n(_n), d(_d) {}<br> 43     int nf() const { return n; } //const 指针 只能绑定 const this*<br> 44     int df() const { return d; } 45 private:<br> 46     int n; 47     int d; 48 };<br> 49 inline const Ration 50 operator*(const Ration&amp; lhs, const Ration&amp; rhs) 51 {<br> 52     return Ration(lhs.nf() * rhs.nf(), lhs.df() * rhs.df()); 53 }<br> 54 #include 55 //Provision_25 Consider support for a non-throwing swap<br> 56 class WidgetImpl //针对Widget数据设计的class<br> 57 {<br> 58 public:<br> 59<br> 60 private:<br> 61     std::vector&lt;double&gt; vd; 62 };<br> 63<br> 64 class Widget 65 {<br> 66 public:<br> 67     Widget&amp; operator=(const Widget&amp; rhs) 68     {<br> 69         //…其他数据<br> 70         *pImpl = *(rhs.pImpl);<br> 71     }<br> 72<br> 73     void swap(Widget&amp; other) //因为使用private member 所以是成员函数<br> 74     {<br> 75         using std::swap; //若没有自定义swap 使用 std::swap<br> 76         swap(pImpl, other.pImpl);<br> 77     }<br> 78 private:<br> 79     WidgetImpl* pImpl; 80 };<br> 81 namespace std 82 {<br> 83     template&lt;&gt; //只是特例化 Widget<br> 84     void swap(Widget&amp; a, Widget&amp; b) 85     {<br> 86         a.swap(b);//调用 swap成员函数<br> 87     }<br> 88 }<br> 89<br> 90 //如果Widget<br> 91 namespace WidgetStuff //不能改变std::swap<br> 92 {<br> 93     template 94     class WidgetImpl 95     {<br> 96     private:<br> 97         std::vector v; 98     };<br> 99<br>100     template 101     class Widget 102 { 103     public: 104         void swap(Widget&amp; other) //因为使用private member 所以是成员函数<br>105 { 106             using std::swap; //若没有自定义swap 使用 std::swap<br>107 swap(pImpl, other.pImpl); 108 } 109     private: 110         WidgetImpl* pImpl; 111 }; 112<br>113     template 114     void swap(Widget&amp; a, Widget&amp; b) 115 { 116 a.swap(b); 117 } 118 }</p><!-- more -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Constructors_Destructor_and_Assignment_Operators</title>
      <link href="/2020/12/17/constructors-destructor-and-assignment-operators/"/>
      <url>/2020/12/17/constructors-destructor-and-assignment-operators/</url>
      
        <content type="html"><![CDATA[<p> 1 //provision_7:Declare destructors virtal in polymorphic base classes<br> 2 /*<br> 3 只有当class 内含有至少一个virtual function 才为它声明virtual destructor<br> 4 不声明 virtual:derived 成分没被销毁<br> 5 没有虚函数时声明 virtual :增加对象体积<br> 6 */<br> 7<br> 8 //provision_8:Prevent exceptions from leaving destructors<br> 9 class DBConnection 10 {<br> 11 public:<br> 12     static DBConnection create(); 13<br> 14     void close();//关闭联机<br> 15 };<br> 16<br> 17 class DBConn //这个class用来管理DBConnection<br> 18 {<br> 19 public:<br> 20     void close()//供用户选择<br> 21     {<br> 22         db.close();<br> 23         closed = true;<br> 24     }<br> 25     ~DBConn()<br> 26     {<br> 27         if (!closed)//如果客户不怎么做<br> 28         {<br> 29             try<br> 30             {<br> 31                 db.close();<br> 32             }<br> 33             catch (…)//捕获所有异常<br> 34             {<br> 35                 //记录 并结束程序 或吞下异常<br> 36             }<br> 37         }<br> 38     }<br> 39 private:<br> 40     DBConnection db;<br> 41     bool closed; 42 };<br> 43<br> 44 //provision_10 Have assignment operators return a reference to *this<br> 45 //避免连锁赋值开销<br> 46 #include&lt;string&gt;<br> 47 #include 48 class Str 49 {<br> 50 public:<br> 51     Str(const std::string&amp; _s = “shuai”) :i(6), s(_s)<br> 52     {<br> 53         std::cout &lt;&lt; “default constructor “ &lt;&lt; std::endl; 54     }<br> 55     Str(const Str&amp; rhs) :i(rhs.i), s(rhs.s) 56     {<br> 57         std::cout &lt;&lt; “copy constructor” &lt;&lt; std::endl; 58     }<br> 59     Str&amp; operator=(const Str&amp; rhs) 60     {<br> 61         i = rhs.i; 62         s = rhs.s; 63         std::cout &lt;&lt; “copy &amp; “ &lt;&lt; std::endl; 64         return *this;<br> 65     }<br> 66<br> 67     /*Str operator=(const Str&amp; rhs)<br> 68     {<br> 69         i = rhs.i;<br> 70         s = rhs.s;<br> 71         std::cout &lt;&lt; “copy no &amp; “ &lt;&lt; std::endl;<br> 72         return *this;<br> 73     }*/<br> 74<br> 75     ~Str()<br> 76     {<br> 77         std::cout &lt;&lt; “destructor” &lt;&lt; std::endl; 78     }<br> 79     const auto&amp; si() const { return i; } 80     const auto&amp; ss() const { return s; } 81 private:<br> 82     int i; 83     std::string s; 84 };<br> 85 int main() 86 {<br> 87     Str s1,s2(“789”),s3(“dui”);<br> 88     s1 = s2 = s3; 89     std::cout &lt;&lt; “s2: “&lt;”s1: “&lt;&lt; s1.ss() &lt;&lt; std::endl; 90     //operator=返回的no_reference 通过 copy constructor 给临时量<br> 91     //但是临时量怎么给S2(临时量是s2产生的副本（猜测）)的：或者返回给S2但是产生了一个临时量<br> 92     //产生多余的copy constructor 和 destructor（临时量）<br> 93     (s1 = s2) = s3;//这时s3 赋值给operator=（s1= s3） 所返回的临时量(返回类型时副本)<br> 94     return 0;<br> 95 }<br> 96<br> 97 //provision_11 Handle assignment to self in operator=<br> 98 //问题：this,rhs 指向同一对象delete this会删除rhs所指向对象<br> 99 class Bitmap {}; 100 class Widget { 101     friend void swap(Widget&amp;, Widget&amp;); 102     Widget&amp; operator=(const Widget&amp; rhs); 103     Widget&amp; operator=(Widget rhs); 104 private: 105     Bitmap* pb; 106 }; 107 Widget&amp;<br>108 Widget::operator=(const Widget&amp; rhs) 109 { 110     delete pb; 111     pb = new Bitmap(*rhs.pb);//rhs.pb所指对象已经被delete<br>112     return *this; 113 } 114 //解决 115<br>116 //method one(identity test): 仍然存在潜在问题：Bitmao copy constructor exception<br>117 Widget&amp;<br>118 Widget::operator=(const Widget&amp; rhs) 119 { 120     if (this == &amp;rhs) return *this; 121     delete pb; 122     pb = new Bitmap(*rhs.pb);//rhs.pb所指对象已经被delete<br>123     return *this; 124 } 125<br>126 //method two:high cost but opereator= 用到次数少<br>127 Widget&amp;<br>128 Widget::operator=(const Widget&amp; rhs) 129 { 130     auto temp = pb; 131     pb = new Bitmap(*rhs.pb); 132     delete temp; 133     return *this; 134 } 135<br>136 //method three(swap) swap:常用来优化代码 并且：如果成员含有子类会调用子类的swap<br>137 inline 138 void swap(Widget &amp;lhs,Widget&amp; rhs) 139 { 140     //当传递类类型的对象时，除了在常规的作用域查找外还会查找实参类所属的命名空间<br>141     using std::swap; 142     swap(lhs.pb, rhs.pb);//自定义的swap匹配优先级更高<br>143 } 144 Widget&amp;<br>145 Widget::operator=(const Widget&amp; rhs) 146 { 147 auto temp(rhs); 148     using std::swap; // 149     swap(*this, temp); 150     return *this; 151 } 152 Widget&amp;<br>153 Widget::operator=(Widget rhs)//“copy 动作”从函数本体移至“函数参数构造阶段”<br>154 { 155     using std::swap; 156     swap(*this,rhs); 157     return *this; 158 } 159<br>160 /*<br>161 copy assignment and copy constructor 不要相互调用：构造：不存在对象， 赋值：对一个已经存在的对象 162 assignment call construct 对一个已经存在的对象进行构造（创建） 163 cosntructor call assignment 对一个还为构造（不存在）的对象进行赋值 164 */</p><!-- more -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Accustoming_Yourself_to_C++</title>
      <link href="/2020/12/16/accustoming-yourself-to-c/"/>
      <url>/2020/12/16/accustoming-yourself-to-c/</url>
      
        <content type="html"><![CDATA[<p>//条款1 用const,enum,inline 替换#define //1 const 替换 #define 常量 /* * 对于浮点数，const double 代码小<br>* 在class内不能提供封装性<br>* #defien函数用<br>* template * inline dectltype(auto) function 替换 */ #include #include&lt;string&gt;<br>class CTextBlock<br>{ public:<br>    size_t length() const; private: private: char* pText;<br>    mutable size_t textLength;<br>    mutable bool lengthIsValid;<br>};</p><p>size_t CTextBlock::length() const { if (!lengthIsValid)<br>    { //function const 由于正在通过常量对象访问“textLength”，因此无法对其进行修改 //解决：mutable<br>        textLength = std::strlen(pText);<br>        lengthIsValid = true;<br>    } return textLength;<br>} //解决 代码只有返回类型的重复问题：令non-const function 调用另一个 const-function<br>class TextBlock<br>{ public: const char&amp; operator[](std::size_t position) const { //bounds chexking //log access data //verify data integrity<br>        return text[position];<br>    } char&amp; operator[](std::size_t position)<br>    { return const_cast&lt;char&amp;&gt;(//去掉 返回值的const<br>                static_cast&lt;const TextBlock&amp;&gt;//调用 operator[]()const<br>                (*this)[position]);<br>    } private:<br>    std::string text;<br>}; //因为为 const 成员函数承若绝不改变其对象的逻辑状态，So don’t const function call non-const function //条款四：Make sure that objects are initialized before they’re used /* *在构造函数中使用()初始化：减少一次copy</p><p>问题：如果某编译单元(cpp)内的某个non-local static对象的初始化<br>      使用了另一个编译单元(cpp)的non-local static对象</p><p>c++对“定义于不同编译单元内的non-local static对象”的初始化次序并无明确定义</p><p>解决：用local static 替换 non-local static(已经被未命名空间取代)</p><p>c++保证：函数内的local static 对象会在“该函数被调用期间”“首次遇上该对象的定义”时被初始化 */<br>class FileSystem<br>{ public:<br>    std::size_t numDisks() const;<br>};<br>inline FileSystem&amp; tfs() //tfs:the file system<br>{ static FileSystem fs; return fs;<br>} class Directory<br>{ public:<br>    Directory() = default;<br>    Directory(std::string params);<br>};<br>Directory::Directory(std::string params)<br>{<br>    std::size_t disks = tfs().numDisks();<br>}<br>inline Directory&amp; tempDir()<br>{ static Directory td; return td;<br>} int main()<br>{ return 0;<br>}</p><!-- more -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Red_Black_Tree C++</title>
      <link href="/2020/11/22/red-black-tree-c/"/>
      <url>/2020/11/22/red-black-tree-c/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91">红黑树</a></p><p>总的来说 掌握思想就好：细节没记住</p><p>//算法导论书中的else表示case3要改成具体情况：还有不存在的情况要跳过<br>//例如：else = else if(z == z.p.left)</p><p>知识点：</p><p>1、指针比较地址 ：z-&gt;right == nil&nbsp; &nbsp; &nbsp;*（z-&gt;right )== *nil 报错：没有定义 operator==&nbsp; &nbsp; &nbsp; 因为：RBT_note_type right 是类类型</p><p>&nbsp; &nbsp; &nbsp; 所以 加一个bool nil 成员处理 或者定义 operator==</p><p>&nbsp;2、auto 需要初始化 ：静态成员初始化要常量 而这里是 不可以</p><p>&nbsp; &nbsp; &nbsp;&nbsp;c++14 中 auto可以作为返回类型，需要注意auto remove const and &amp;</p><p>3、constexpr:如果传递给一个constexpr function 的实参在编译期已知，结果也是在编译期已知</p><p>例如 ：《Effective Modern C++》</p><p>#pragma once<br>class Point<br>{ public:<br>    constexpr Point(double xVal = 0, double yVal = 0) noexcept<br>        :x(xVal), y(yVal) {}<br>    constexpr double xValue() const noexcept { return x; }<br>    constexpr double yValue() const noexcept { return y; } void setX(double newX) noexcept { x = newX; } void setY(double newY) noexcept { y = newY; } private: double x; double y;<br>};</p><p>constexpr<br>Point midpoint(const Point&amp; p1, const Point&amp; p2) noexcept<br>{ return { (p1.xValue() + p2.xValue()) / 2,<br>        (p1.yValue() + p2.yValue()) / 2 };<br>}</p><p>constexpr auto mid = midpoint(p1, p2); </p><p>static_cast(mid.xValue()*10) 可用于模板形参</p><p>红黑树是每个节点都带有_颜色_属性的<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9" title="二叉搜索树">二叉查找树</a>，颜色为_红色_或_黑色_。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求：</p><ol><li> 节点是红色或黑色。</li><li> 根是黑色。</li><li> 所有叶子都是黑色（叶子是NIL节点）。</li><li> 每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）</li><li> 从任一节点到其每个叶子的所有<a href="https://zh.wikipedia.org/wiki/%E9%81%93%E8%B7%AF_(%E5%9B%BE%E8%AE%BA)" title="道路 (图论)">简单路径</a>都包含相同数目的黑色节点。</li></ol><p>下面是一个具体的红黑树的图</p><p><img src="https://img2020.cnblogs.com/blog/2092141/202011/2092141-20201122222248190-1465512193.png"></p><p>这些约束确保了红黑树的关键特性：从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91" title="二叉查找树">二叉查找树</a>。</p><p>要知道为什么这些性质确保了这个结果，注意到性质4导致了路径不能有两个毗连的红色节点就足够了。最短的可能路径都是黑色节点，最长的可能路径有交替的红色和黑色节点。因为根据性质5所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。</p><p>在很多树数据结构的表示中，一个节点有可能只有一个子节点，而叶子节点包含数据。用这种范例表示红黑树是可能的，但是这会改变一些性质并使算法复杂。为此，本文中我们使用”nil叶子”或”空（null）叶子”，如上图所示，它不包含数据而只充当树在此结束的指示。这些节点在绘图中经常被省略，导致了这些树好像同上述原则相矛盾，而实际上不是这样。与此有关的结论是所有节点都有两个子节点，尽管其中的一个或两个可能是空叶子。</p><p>#RED_BLACK_TREE_NOTE.h</p><p>#pragma once #include #include //优先选用限定作用域的enum // 降低空间污染 //不会隐式转换 //color<br>enum class color<br>{ //默认const int不能默认转换<br> red,black<br>}; //友元所需声明<br>template class Red_Black_Tree;<br>template class Red_Black_Tree_Note; //using 声明<br>template using RBT_note_type = std::shared_ptr&gt;;<br>template void Right_Rotate(Red_Black_Tree &amp;Tree<br>    , RBT_note_type y);<br>template void Left_Rotate(Red_Black_Tree &amp;Tree,<br>    RBT_note_type x);<br>template void RB_Transplant(Red_Black_Tree&amp; Tree<br>    , RBT_note_type &amp;u, RBT_note_type &amp;v); //Note<br>template class Red_Black_Tree_Note<br>{<br>    friend class Red_Black_Tree;<br>    friend void Left_Rotate(Red_Black_Tree&amp; , RBT_note_type);<br>    friend void Right_Rotate(Red_Black_Tree&amp; , RBT_note_type);<br>    friend void RB_Transplant(Red_Black_Tree&amp; Tree<br>        , RBT_note_type &amp;u, RBT_note_type &amp;v); public:<br>    Red_Black_Tree_Note(const T&amp; _key = T())<br>        :key(_key),left(std::make_shared&gt;(‘*‘)),<br>        right(std::make_shared&gt;(‘*‘)), p(nullptr),tree_color(color::black),nil(false) {}<br>    Red_Black_Tree_Note(char)<br>        :key(T()),left(nullptr), right(nullptr), p(nullptr), tree_color(color::black),nil(true) {} private:<br>    T key;<br>    RBT_note_type left;<br>    RBT_note_type right;<br>    RBT_note_type p;<br>    color tree_color; bool nil;<br>}; //左旋<br>template void Left_Rotate(Red_Black_Tree &amp;Tree, RBT_note_type x)<br>{<br>    auto y(x-&gt;right);<br>    x-&gt;right = y-&gt;left; if (y-&gt;left-&gt;nil != true)<br>        y-&gt;left-&gt;p = x;<br>    y-&gt;p = x-&gt;p;<br>    if (x-&gt;p-&gt;nil == true)<br>        Tree.root = y; else if (x == x-&gt;p-&gt;left)<br>        x-&gt;p-&gt;left = y; else x-&gt;p-&gt;right = y;<br>    y-&gt;left = x;<br>    x-&gt;p = y;<br>} //右旋<br>template void Right_Rotate(Red_Black_Tree &amp;Tree<br>    , RBT_note_type y)<br>{<br>    auto x(y-&gt;left);<br>    y-&gt;left = x-&gt;right; if (x-&gt;right-&gt;nil != true)<br>        x-&gt;right-&gt;p = y;<br>    x-&gt;p = y-&gt;p; if (y-&gt;p-&gt;nil == true) //C2232“-&gt;Red_Black_Tree::root”: 左操作数有“class”类型，使用“.”<br>        Tree.root = x; else if (y == y-&gt;p-&gt;right)<br>        y-&gt;p-&gt;right = x; else y-&gt;p-&gt;left = x;<br>    x-&gt;right = y;<br>    y-&gt;p = x;<br>} //移植<br>template void RB_Transplant(Red_Black_Tree&amp; Tree<br>    ,RBT_note_type &amp;u,RBT_note_type &amp;v)<br>{ //u-&gt;p 不存在 // if (u-&gt;p == Tree.nil)<br>    if(u-&gt;p-&gt;nil == true)<br>        Tree.root = v; //报错：读取访问权限冲突：解决把函数放在Tree类 private<br>    else if (u == u-&gt;p-&gt;left)<br>        u-&gt;p-&gt;left = v; else u-&gt;p-&gt;right = v;<br>    v-&gt;p = u-&gt;p;<br>}</p><p>#RED_BLACK_TREE.h</p><p>#pragma once<br>//算法导论书中的else表示case3要改成具体情况：还有不存在的情况要跳过 //例如：else = else if(z == z.p.left)<br>#include #include //less<br>#include”RED_BLACK_TREE_NOTE.h” template class Red_Black_Tree<br>{<br>    friend void Left_Rotate(Red_Black_Tree &amp;Tree<br>        , RBT_note_type x);<br>    friend void Right_Rotate(Red_Black_Tree &amp;Tree<br>        , RBT_note_type x);<br>    friend void RB_Transplant(Red_Black_Tree&amp; Tree<br>        , RBT_note_type &amp;u, RBT_note_type &amp;v); public:<br>    Red_Black_Tree() :nil(std::make_shared&gt;(‘*‘)),root(std::make_shared&gt;(‘*‘)) {} //中序遍历<br>    void Iorder_Tree_Walk(const RBT_note_type &amp;x); void Iorder_Tree_Walk() { Iorder_Tree_Walk(root); } //迭代查找 迭代改变要搜索的x 不能引用&amp;x //c++14 中 auto可以作为返回类型，需要注意auto remove const and &amp; //若要完成版 则：decltype(auto) return std::forward(x); forward 处理右值情况<br>    auto Iterative_Tree_Search(const T&amp; key, RBT_note_type x); bool Iterative_Tree_Search(const T&amp; key)<br>    {<br>        auto p = Iterative_Tree_Search(key, root); if (p != nullptr &amp;&amp; p-&gt;nil != true) return true; else<br>            return false;<br>    } //最小值 : 迭代搜索 不能 &amp;x ,不能返回引用：p是局部变量程序<br>    RBT_note_type Tree_Minimum(RBT_note_type x);<br>    T Tree_Minimum()<br>    {<br>        auto p = Tree_Minimum(root); return p-&gt;key;<br>    } //插入<br>    void RB_INSERT(const RBT_note_type &amp;z); void RB_Insert(const T&amp; key)<br>    {<br>        auto z = std::make_shared&gt;(key);<br>        RB_INSERT(z);<br>    } //删除<br>    void RB_DELETE(RBT_note_type z); void RB_Delete(const T&amp; key)<br>    {<br>        auto z = Iterative_Tree_Search(key, root); if (z == nullptr || z-&gt;nil == true)<br>            std::cerr &lt;&lt; “nodata!”; else RB_DELETE(z);<br>    } private:<br>    RBT_note_type root; //非静态成员不能使用auto //静态成员初始化要用常量 这里是模板<br>    RBT_note_type nil; void RB_INSERT_FIXUP(RBT_note_type z); void RB_DELETE_FIXUP(RBT_note_type z);<br>}; //中序遍历中nil的key值要排除<br>template inline void Red_Black_Tree::Iorder_Tree_Walk(const RBT_note_type &amp;x)<br>{ if (x != nullptr&amp;&amp;x-&gt;nil != true)<br>    {<br>        Iorder_Tree_Walk(x-&gt;left);<br>        std::cout &lt;&lt; x-&gt;key &lt;&lt; “ “;<br>        Iorder_Tree_Walk(x-&gt;right);<br>    }<br>}<br>template inline auto Red_Black_Tree::Iterative_Tree_Search(const T&amp; key, RBT_note_type x)<br>{ while (x != nullptr &amp;&amp; x-&gt;nil != true &amp;&amp; key != x-&gt;key)<br>    { if (key &lt; x-&gt;key) // if(std::less(key,x-&gt;key)) //const key 无法转换<br>            x = x-&gt;left; else x = x-&gt;right;<br>    } return x;<br>} //最小值<br>template RBT_note_type Red_Black_Tree::Tree_Minimum(RBT_note_type x)<br>{ while (x-&gt;left != nullptr &amp;&amp; x-&gt;left-&gt;nil != true)<br>        x = x-&gt;left; return x;<br>} //插入<br>template void Red_Black_Tree::RB_INSERT_FIXUP(RBT_note_type z)<br>{ while (z-&gt;p-&gt;tree_color == color::red)<br>    { if (z-&gt;p == z-&gt;p-&gt;p-&gt;left)<br>        {<br>            auto y(z-&gt;p-&gt;p-&gt;right); if (y-&gt;tree_color == color::red)<br>            {<br>                z-&gt;p-&gt;tree_color = color::black;<br>                y-&gt; tree_color = color::black;<br>                z-&gt; p-&gt; p-&gt;tree_color = color::black;<br>                z = z-&gt;p-&gt;p;<br>            } else if (z == z-&gt;p-&gt;right)<br>            {<br>                z = z-&gt;p;<br>                Left_Rotate(*this, z);<br>            } else if (z == z-&gt;p-&gt;left)<br>            {<br>                z-&gt;p-&gt;tree_color = color::black;<br>                z-&gt;p-&gt;p-&gt;tree_color = color::red;<br>                Right_Rotate(*this, z-&gt;p-&gt;p);<br>            }<br>        } else if (z-&gt;p == z-&gt;p-&gt;p-&gt;right)<br>        {<br>                auto y(z-&gt;p-&gt;p-&gt;left); //case1<br>                if (y-&gt;tree_color == color::red)<br>                {<br>                    z-&gt;p-&gt;tree_color = color::black;<br>                    y-&gt;tree_color = color::black;<br>                    z-&gt;p-&gt;p-&gt;tree_color = color::black;<br>                    z = z-&gt;p-&gt;p;<br>                } //case2<br>                else if (z == z-&gt;p-&gt;left)<br>                {<br>                    z = z-&gt;p;<br>                    Right_Rotate(*this, z);<br>                } //case3<br>                else if (z == z-&gt;p-&gt;right)<br>                {<br>                    z-&gt;p-&gt;tree_color = color::black; //在插入第三个数时，因为case1 z = z.p.p执行后z为root //则z.p.p为无效内存，不可访问会报错<br>                    z-&gt;p-&gt;p-&gt;tree_color = color::red;<br>                    Left_Rotate(*this, z-&gt;p-&gt;p);<br>                }<br>        }<br>            root-&gt;tree_color = color::black;<br>    }<br>}</p><p>template void Red_Black_Tree::RB_INSERT(const RBT_note_type &amp;z)<br>{<br>    auto y(nil);<br>    auto x(root); //不知道为什么 while(x != nil) 条件会通过 没有 operator!= // x = root = nil = (‘*‘)<br>    while (x-&gt;nil != true)<br>    {<br>        y = x; if (z-&gt;key &lt; x-&gt;key)<br>            x = x-&gt;left; else x = x-&gt;right;<br>    }<br>    z-&gt;p = y; if (y-&gt;nil == true)<br>        root = z; else if (z-&gt;key &lt; y-&gt;key)<br>        y-&gt;left = z; else y-&gt;right = z;<br>    z-&gt;left = nil;<br>    z-&gt;right = nil;<br>    z-&gt;tree_color = color::red;//如果黑色必然违反规则：每条路上黑色结点数相同<br> RB_INSERT_FIXUP(z);<br>} //删除<br>template void Red_Black_Tree::RB_DELETE_FIXUP(RBT_note_type x)<br>{ while (x != root &amp;&amp; x-&gt;tree_color == color::black)<br>    { if (x == x-&gt;p-&gt;left)<br>        {<br>            auto w(x-&gt;p-&gt;right); //case1<br>            if (w-&gt;tree_color == color::red)<br>            {<br>                w-&gt;tree_color = color::black;<br>                x-&gt;p-&gt;tree_color = color::red;<br>                Left_Rotate(*this, x-&gt;p);<br>                w = x-&gt;p-&gt;right;<br>            } //case2<br>            if (w-&gt;left-&gt;tree_color == color::black &amp;&amp; w-&gt;right-&gt;tree_color == color::black)<br>            {<br>                w-&gt;tree_color = color::red;<br>                x = x-&gt;p;<br>            } //case3<br>            else if (w-&gt;right-&gt;tree_color == color::black)<br>            {<br>                w-&gt;left-&gt;tree_color = color::black;<br>                w-&gt;tree_color = color::red;<br>                Right_Rotate(*this, w);<br>                w = x-&gt;p-&gt;right;<br>            }<br>            w-&gt;tree_color = x-&gt;p-&gt;tree_color;<br>            x-&gt;p-&gt;tree_color = color::black;<br>            w-&gt;right-&gt;tree_color = color::black;<br>            Left_Rotate(*this, x-&gt;p);<br>            x = root;<br>        } if (x == x-&gt;p-&gt;right)<br>        {<br>            auto w(x-&gt;p-&gt;left); if (w-&gt;tree_color == color::red)<br>            {<br>                w-&gt;tree_color = color::black;<br>                x-&gt;p-&gt;tree_color = color::red;<br>                Right_Rotate(*this, x-&gt;p);<br>                w = x-&gt;p-&gt;left;<br>            } if (w-&gt;right-&gt;tree_color == color::black &amp;&amp; w-&gt;left-&gt;tree_color == color::black)<br>            {<br>                w-&gt;tree_color = color::red;<br>                x = x-&gt;p;<br>            } else if (w-&gt;left-&gt;tree_color == color::black)<br>            {<br>                w-&gt;right-&gt;tree_color = color::black;<br>                w-&gt;tree_color = color::red;<br>                Left_Rotate(*this, w);<br>                w = x-&gt;p-&gt;left;<br>            }<br>            w-&gt;tree_color = x-&gt;p-&gt;tree_color;<br>            x-&gt;p-&gt;tree_color = color::black;<br>            w-&gt;left-&gt;tree_color = color::black;<br>            Right_Rotate(*this, x-&gt;p);<br>            x = root;<br>        }<br>    }<br>    x-&gt;tree_color = color::black;<br>}<br>template void Red_Black_Tree::RB_DELETE(RBT_note_type z)<br>{<br>    auto y(z);<br>    auto x(nil);<br>    color y_original_color = y-&gt;tree_color; if (z-&gt;left-&gt;nil == true)<br>    {<br>        x=z-&gt;right;<br>        RB_Transplant(*this, z, z-&gt;right);<br>    } //else if (z-&gt;right == nil || z-&gt;right == nullptr) 会跳过<br>    else if (z-&gt;right-&gt;nil == true)<br>    {<br>        x = z-&gt;left;<br>        RB_Transplant(*this, z, z-&gt;left);<br>    } else {<br>        y = Tree_Minimum(z-&gt;right);<br>        y_original_color = y-&gt;tree_color;<br>        x = y-&gt;right; if (y-&gt;p == z)<br>            x-&gt;p = y; else {<br>            RB_Transplant(*this, y, y-&gt;right);<br>            y-&gt;right = z-&gt;right;<br>            y-&gt;right-&gt;p = y;<br>        }<br>        RB_Transplant(*this, z, y);<br>        y-&gt;left = z-&gt;left;<br>        y-&gt;left-&gt;p = y;<br>        y-&gt;tree_color = z-&gt;tree_color;<br>    } if (y_original_color == color::black)<br>        RB_DELETE_FIXUP(x);<br>}</p><p>main.cpp</p><p>#include #include #include”Binary_Seach_Tree.h” #include”RED_BLACK_TREE.h”</p><p>using namespace std; /* void BSTree()<br>{<br>    vector vi{ 1,2,5,8,6,9,6 };<br>    BST t;<br>    //插入<br>    for (auto i = 0;i != vi.size();++i)<br>        t.Tree_Insert(vi[i]);<br>    cout &lt;&lt; “中序遍历” &lt;&lt; endl;<br>    t.Iorder_Tree_Walk();<br>    cout &lt;&lt; endl;<br>    cout &lt;&lt; “最大值” &lt;&lt; endl;<br>    cout &lt;&lt; t.Tree_Maximum() &lt;&lt; endl;<br>    cout &lt;&lt; “最小值” &lt;&lt; endl;<br>    cout &lt;&lt; t.Tree_Minimum() &lt;&lt; endl;<br>    cout &lt;&lt; “查找” &lt;&lt; endl;<br>    cout &lt;&lt; boolalpha &lt;&lt; t.Tree_Seach(8) &lt;&lt; endl;<br>    cout &lt;&lt; “删除” &lt;&lt; endl;<br>    t.Tree_Delete(8);<br>    cout &lt;&lt; boolalpha &lt;&lt; t.Iterative_Tree_Search(8) &lt;&lt; endl;<br>} */</p><p>void RBT()<br>{<br>    vector&lt;int&gt; vi{ 1,2,5,4,6,3,99,1,-6 };<br>    Red_Black_Tree&lt;int&gt; t; for (const auto&amp; i : vi)<br>        t.RB_Insert(i);<br>    t.Iorder_Tree_Walk();<br>    cout &lt;&lt; endl;<br>    t.RB_Delete(99);<br>    t.Iorder_Tree_Walk();<br>    cout &lt;&lt; endl;<br>    t.RB_Delete(1);<br>    t.Iorder_Tree_Walk();<br>} int main()<br>{<br>    RBT(); string s1{ “abc” }; string s2{ “acd” }; if (s1 &gt; s2)<br>        cout &lt;&lt; “66”; const int i = 0;<br>    auto y = i;<br>    y = 6; return 0;<br>}</p><!-- more -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Binary_Seach_Tree(BST)    C++</title>
      <link href="/2020/11/07/binary-seach-tree-bst-c/"/>
      <url>/2020/11/07/binary-seach-tree-bst-c/</url>
      
        <content type="html"><![CDATA[<p><strong><a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9">Wiki</a>：二叉查找树</strong>（英语：Binary Search Tree），也称为<strong>二叉搜索树</strong>、<strong>有序二叉树</strong>（ordered binary tree）或<strong>排序二叉树</strong>（sorted binary tree），是指一棵空树或者具有下列性质的<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91" title="二叉树">二叉树</a>：</p><ol><li> 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li><li> 若任意节点的右子树不空，则右子树上所有节点的值均大于或等于它的根节点的值；</li><li> 任意节点的左、右子树也分别为二叉查找树</li></ol><p>总的来说：<strong>《c++ primr 5th》每次看都觉得厉害</strong></p><p>1、shared_ptr 是真的香</p><p>2、template 友元用的时候在看</p><p>3、函数传递：指针形参属于传值（拷贝），shared_ptr引用传递 没必要：动态内存（猜测）</p><p>4、cosnt 成员函数适用：不能把this指针 绑定到常量对象（如const double pi = 3.14）:return pi;</p><p>具体学习到什么 看code注释</p><p> 1 #pragma once<br> 2 //编译器需要掌握函数模板或模板成员函数的定义：成员函数定义 也在头文件中<br> 3 //成员函数定义在类外使用默认实参 报错：不允许使用默认参数（原因还未知）<br> 4 //原因：非静态数据成员不能作为默认实参：因为它的值本身属于对象的一部分，<br> 5 //这么做的结果是：无法真正提供一个对象以便从中获取成员的值<br> 6<br> 7  /*<br> 8  指针传递：形参是指针的拷贝，两个指针是不同的指针 但是可以间接修改所指向对象的值<br> 9  尽量使用引用传递：避免拷贝的效率和空间<br> 10  尽量使用值初始化：避免多余默认初始化<br> 11  type* &amp; ：指向指针的引用 ：引用本身不是对象所以不能定义指向引用的指针<br> 12  =运算符在结点上的意义是什么？ 指针之间的赋值操作：所以不需要定义赋值运算符不是类之间操作<br> 13  类的行为像指针：共享状态 最好的方法是使用shared_ptr<br> 14  */<br> 15<br> 16 #include 17 #include //shared_ptr<br> 18 template class BST;//前置声明：友元所需要<br> 19 template 20 //在Tree_Note类内：直接使用模板名而不提供实参：Tree_Note = Tree_Note<br> 21 class Tree_Note 22 {<br> 23     friend class BST;//每个Tree_Note实例将访问权限授予用相同类型实例化的BST<br> 24 public:<br> 25     //构造函数<br> 26     Tree_Note(const T&amp; _key = T()) 27         :left(nullptr), right(nullptr), parent(nullptr),key(_key){}<br> 28     /*<br> 29     stack overflow why???<br> 30     答：make_shared 调用Tree_Note构造函数则造成无线循环<br> 31         而用内置已经存在构造函数的则不会 ：data(make_shared&gt;()):data = “”  32         :left(std::make_shared()),  33         right(std::make_shared()), parent(std::make_shared()),key(_key) {}  34     */<br> 35     /* 没用上拷贝构造 36     //为了与内置运算符一致：返回指向左侧运算对象的引用:<br> 37     decltype(auto) operator=(std::make_ptr right)  38     {//decltype(auto)详见：《Effective Modern C++》P31<br> 39         key = right.key;<br> 40         return maked_shared(*this);  41     }<br> 42     */<br> 43 private:<br> 44     T key;<br> 45     std::shared_ptr left; 46     std::shared_ptr right; 47     std::shared_ptr parent; 48 };<br> 49<br> 50 template 51 class BST 52 {<br> 53 public:<br> 54     //若root(nullptr) 则：报错访问内存受限<br> 55     BST() :root(nullptr) {} //若使用构造函数则 root.key = 0<br> 56     //中序遍历<br> 57     void Iorder_Tree_Walk(const std::shared_ptr&gt; x); 58     void Iorder_Tree_Walk() {Iorder_Tree_Walk(root);} 59     //递归查找<br> 60     std::shared_ptr&gt; Tree_Search(const T&amp; key,const std::shared_ptr&gt; x); 61     bool Tree_Seach(const T&amp; key) 62     {<br> 63         auto p = Tree_Search(key, root); 64         if (p != nullptr) 65             return true;<br> 66         else<br> 67             return false;<br> 68     }<br> 69     //迭代查找:对于大多数计算机，迭代版本的效率要高的多 ：调用函数开销<br> 70     std::shared_ptr&gt; Iterative_Tree_Search(const T&amp; key,std::shared_ptr&gt; x); 71     bool Iterative_Tree_Search(const T&amp; key) 72     {<br> 73         auto p = Iterative_Tree_Search(key, root); 74         if (p != nullptr) 75             return true;<br> 76         else<br> 77             return false;<br> 78     }<br> 79<br> 80     //最小值<br> 81     std::shared_ptr&gt; Tree_Minimum(std::shared_ptr&gt; x); 82     T Tree_Minimum()<br> 83     {<br> 84         auto p = Tree_Minimum(root); 85         return p-&gt;key;<br> 86     }<br> 87     //最大值<br> 88     std::shared_ptr&gt; Tree_Maximum(std::shared_ptr&gt; x); 89     T Tree_Maximum()<br> 90     {<br> 91         auto p = Tree_Maximum(root); 92         return p-&gt;key;<br> 93     }<br> 94<br> 95     //后继和前驱:最接近（大小）该节点的大、小节点<br> 96     std::shared_ptr&gt; Tree_Successor(std::shared_ptr&gt; x); 97     std::shared_ptr&gt; Tree_Predecessor(std::shared_ptr&gt; x); 98<br> 99     //插入和删除<br>100     void Tree_Insert(std::shared_ptr&gt; z); //当为空树是z要赋值给root 而root不能是const,所以z不是const<br>101     void Tree_Insert(const T&amp; key) 102 { 103         auto z = std::make_shared&gt;(key); 104 Tree_Insert(z); 105 } 106     void Tree_Delete(std::shared_ptr&gt; z); 107     void Tree_Delete(const T&amp; key) 108 { 109         auto z = Iterative_Tree_Search(key, root); 110         if (z == nullptr) 111             std::cerr &lt;&lt; “nodata!”; 112 Tree_Delete(z); 113 } 114 private: 115     std::shared_ptr&gt; root; 116     //移植节点 :u = v(不包括左右孩子)<br>117     void Transplant(std::shared_ptr&gt; u, std::shared_ptr&gt; v) 118 { 119         //指针给指针赋值：右侧地址赋值给左侧地址（指针存储的是地址）<br>120         if (u-&gt;parent == nullptr) //如果u是根节点<br>121             root = v; 122         //都用 v替代u了 u的父节点不也被替代了么?—属于指针的赋值而不是类所以不用定于赋值运算符<br>123         else if (u == u-&gt;parent-&gt;left) //如果U是左孩子<br>124             u-&gt;parent-&gt;left = v; 125         else<br>126             u-&gt;parent-&gt;right = v; 127         if (v-&gt;parent != nullptr) 128             v-&gt;parent = u-&gt;parent;//不改变被替换树的上层<br>129 } 130 }; 131<br>132 //成员函数定义在类外使用默认实参 报错：不允许使用默认参数 133 //原因(P271 《c++ prime 5th》)：非静态数据成员不能作为默认实参：因为它的值本身属于对象的一部分， 134 //这么做的结果是：无法真正提供一个对象以便从中获取成员的值 135<br>136 //递归查找<br>137 template 138 std::shared_ptr&gt;<br>139 BST::Tree_Search(const T&amp; key,const std::shared_ptr&gt; x) 140 { 141     if (x == nullptr || key == x-&gt;key) 142         return x; 143     if (key &lt; x-&gt;key)//在左侧子树<br>144         return Tree_Search(key,x-&gt;left); 145     else//右侧子树<br>146         return Tree_Search(key,x-&gt;right); 147 } 148 //迭代查找:对于大多数计算机，迭代版本的效率要高的多 ：调用函数开销<br>149 template 150 std::shared_ptr&gt;<br>151 BST::Iterative_Tree_Search(const T&amp; key,std::shared_ptr&gt; x) 152 { 153     while (x != nullptr &amp;&amp; key != x-&gt;key) 154 { 155         if (key &lt; x-&gt;key) 156             x = x-&gt;left; 157         else<br>158             x = x-&gt;right; 159 } 160     return x; 161 } 162 //中序遍历<br>163 template 164 void BST::Iorder_Tree_Walk(const std::shared_ptr&gt; x) 165 { 166     if (x != nullptr) 167 { 168         Iorder_Tree_Walk(x-&gt;left); 169         std::cout &lt;&lt; x-&gt;key &lt;&lt; “ “; 170         Iorder_Tree_Walk(x-&gt;right); 171 } 172 } 173 //最小值<br>174 template 175 std::shared_ptr&gt;<br>176 BST::Tree_Minimum(std::shared_ptr&gt; x) 177 { 178     while (x-&gt;left != nullptr) 179         x = x-&gt;left; 180     return x; 181 } 182 //最大值<br>183 template 184 std::shared_ptr&gt;<br>185 BST::Tree_Maximum(std::shared_ptr&gt; x) 186 { 187     while (x-&gt;right != nullptr) 188         x = x-&gt;right; 189     return x; 190 } 191 //后继和前驱<br>192 template 193 std::shared_ptr&gt;<br>194 BST::Tree_Successor(std::shared_ptr&gt; x) 195 { 196     if (x-&gt;right != nullptr) // 对接近大于x的节点 处在右子树中最小值<br>197         return Tree_Minimum(x-&gt;right); 198     //从x开始向上寻找节点：该结点不是父节点的右孩子 （如果是右孩子则x.right不会为空）<br>199     auto y(x-&gt;parent); 200     while (y != nullptr &amp;&amp; x == y-&gt;right) 201 { 202         x = y; 203         y = y-&gt;parent; 204 } 205     return y;//第一个不是右孩子的节点<br>206 } 207 template 208 std::shared_ptr&gt;<br>209 BST::Tree_Predecessor(std::shared_ptr&gt; x) 210 { 211     if (x-&gt;left != nullptr) 212         return Tree_Maximum(x-&gt;right); 213     auto y = x-&gt;parent; 214     while (y != nullptr &amp;&amp; x == y-&gt;left) 215 { 216         x = y; 217         y = y-&gt;parent; 218 } 219     return y; 220 } 221<br>222 //插入和删除<br>223 template 224 void BST::Tree_Insert(std::shared_ptr&gt; z) 225 { 226     //临时量用于确定z位置：不要调用make_shared 则不满足 !=nullptr 为空树时条件<br>227     std::shared_ptr&gt; y = nullptr; 228 // auto y = std::make_shared&gt;();<br>229 auto x(root); 230     //当x为空时，x就是待插入的位置<br>231     while (x != nullptr) 232 { 233         y = x; 234         if (z-&gt;key &lt; x-&gt;key) 235             x = x-&gt;left; 236         else//包括相等的情况 具有稳定性：后插入的在右边<br>237             x = x-&gt;right; 238 } 239     z-&gt;parent = y; 240     if (y == nullptr) 241         root = z; 242     else if (z-&gt;key &lt; y-&gt;key) 243         y-&gt;left = z; 244     else<br>245         y-&gt;right = z; 246 } 247<br>248 template 249 void BST::Tree_Delete(std::shared_ptr&gt; z) 250 { 251     if (z-&gt;left == nullptr) //(a)<br>252         Transplant(z, z-&gt;right); 253     else if (z-&gt;right == nullptr) //(b)<br>254         Transplant(z, z-&gt;left); 255     else<br>256 { 257         auto y = Tree_Minimum(z-&gt;right); 258         if (y-&gt;parent != z) //(c):y不是z的右孩子<br>259 { 260             Transplant(y, y-&gt;right); 261             y-&gt;right = z-&gt;right; 262             y-&gt;right-&gt;parent = y; 263 } 264         //(d):y是z的右孩子 且y,left == nullptr 如果y的左孩子不是空则 y不是z的后继<br>265 Transplant(z, y); 266         y-&gt;left = z-&gt;left; //y的左孩子（拼接）指向被删除点z的左孩子<br>267         y-&gt;left-&gt;parent = y; //相当于 z = y<br>268 } 269 }</p><p>main</p><p> 1 #include 2 #include 3 #include”Binary_Seach_Tree.h”<br> 4 using namespace std; 5<br> 6 void BSTree() 7 {<br> 8     vector&lt;int&gt; vi{ 1,2,5,8,6,9,6 }; 9     BST&lt;int&gt; t; 10     //插入<br>11     for (auto i = 0;i != vi.size();++i) 12 t.Tree_Insert(vi[i]); 13     cout &lt;&lt; “中序遍历” &lt;&lt; endl; 14 t.Iorder_Tree_Walk(); 15     cout &lt;&lt; endl; 16     cout &lt;&lt; “最大值” &lt;&lt; endl; 17     cout &lt;&lt; t.Tree_Maximum() &lt;&lt; endl; 18     cout &lt;&lt; “最小值” &lt;&lt; endl; 19     cout &lt;&lt; t.Tree_Minimum() &lt;&lt; endl; 20     cout &lt;&lt; “查找” &lt;&lt; endl; 21     cout &lt;&lt; boolalpha &lt;&lt; t.Tree_Seach(8) &lt;&lt; endl; 22     cout &lt;&lt; “删除” &lt;&lt; endl; 23     t.Tree_Delete(8); 24     cout &lt;&lt; boolalpha &lt;&lt; t.Iterative_Tree_Search(8) &lt;&lt; endl; 25 } 26<br>27<br>28 int main() 29 { 30 BSTree(); 31     return 0; 32 }</p><p>删除：form 《算法导论》 P167</p><p><img src="https://img2020.cnblogs.com/blog/2092141/202011/2092141-20201107120342901-1844958442.png"></p><p>关于其他操作请看<a href="https://www.cnblogs.com/skywang12345/p/3576373.html">二叉查找树(二)之 C++的实现</a></p><!-- more -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>贪吃蛇小笔记</title>
      <link href="/2020/10/29/tan-chi-she-xiao-bi-ji/tan-chi-she-xiao-bi-ji/"/>
      <url>/2020/10/29/tan-chi-she-xiao-bi-ji/tan-chi-she-xiao-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="贪吃蛇GreedySnake（转载）"><a href="#贪吃蛇GreedySnake（转载）" class="headerlink" title="贪吃蛇GreedySnake（转载）"></a><a href="https://blog.csdn.net/silence1772/article/details/55005008">贪吃蛇GreedySnake</a>（转载）</h1><p>如果《c++ prime 5th》 课后程序都自己敲一遍：这个程序（没有继承）很好理解</p><p>一些window API&nbsp; 检测输入什么的 跳过也行</p><p>用一个controller 类来总控制&nbsp;</p><p>：<a href="https://blog.csdn.net/silence1772/article/details/55005008">整个游戏其实就是一个无穷的循环，直到退出游戏时退出循环。我们暂且将这个循环称为一级循环，这个循环包含游戏开始动画，游戏难度选择，游戏过程这三个子模块，其中游戏过程这个模块亦是一个循环，我们暂且将其称为二级循环</a></p><p>int tmp = PlayGame();//开启游戏循环，当重新开始或退出游戏时，结束循环并返回值给tmp</p><p>动画就是一层一层的覆盖 和 刷新</p><p>关于线程。。。。因该和同一层次的循环有关（不了解还没学）</p><p>总的来说：如果第一次编写小游戏还是有收获的（尤其是界面选择）</p><p>有时间的话 折腾下 <a href="https://stackoverflow.com/questions/18028808/remove-blinking-underscore-on-console-cmd-prompt">光标</a>、输入按键、c++可替代部分</p><h1 id="C语言使用getch-读取方向键"><a href="#C语言使用getch-读取方向键" class="headerlink" title="C语言使用getch()读取方向键"></a><a href="https://blog.csdn.net/u013521296/article/details/77103697">C语言使用getch()读取方向键</a></h1><h1 id="关于键盘方向键的ASCII的问题解释"><a href="#关于键盘方向键的ASCII的问题解释" class="headerlink" title="关于键盘方向键的ASCII的问题解释"></a><a href="https://blog.csdn.net/feilong911hao/article/details/42081967">关于键盘方向键的ASCII的问题解释</a></h1><!-- more -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Randomized_Select C++</title>
      <link href="/2020/10/24/randomized-select-c/"/>
      <url>/2020/10/24/randomized-select-c/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9">Wiki</a>:</p><p>快速选择的总体思路与<a href="https://www.cnblogs.com/Z-s-c11/p/13828262.html">快速排序</a>一致，选择一个元素作为基准来对元素进行分区，将小于和大于基准的元素分在基准左边和右边的两个区域。不同的是，快速选择并不递归访问双边，而是只递归进入一边的元素中继续寻找。这降低了平均时间复杂度，从O(<em>n</em>&nbsp;log&nbsp;<em>n</em>)至O(<em>n</em>)，不过最坏情况仍然是O(_n_2)。</p><p><img src="https://img2020.cnblogs.com/blog/2092141/202010/2092141-20201024212758252-13371777.gif"></p><p>code</p><p> 1 #pragma once<br> 2 #include 3 #include 4<br> 5 int Partiton(std::vector&lt;int&gt;&amp; A, const int p, const int r) 6 {<br> 7     //int 有-1值<br> 8     int i = p - 1;<br> 9     //A[r]是主元不参与划分数组 j != r<br>10     for (int j = p;j != r;++j) 11 { 12         if (A[j] &lt; A[r]) 13 { 14             ++i; 15 std::swap(A[i], A[j]); 16 } 17 } 18     std::swap(A[i + 1], A[r]); 19     return i + 1; 20 } 21 int Randomized_Partition(std::vector&lt;int&gt;&amp; A, int p, int r) 22 { 23 std::default_random_engine e; 24     std::uniform_int_distribution u(p, r); 25     int i = u(e); 26 std::swap(A[r], A[i]); 27     return Partiton(A, p, r); 28 } 29<br>30 int Randomized_Select(std::vector&lt;int&gt;&amp; A, const int p, const int r, const int i) 31 { 32     if (p == r) 33         return A[p]; 34     int q = Randomized_Partition(A, p, r); 35     int k = q - p + 1; 36     if (i == k)//i为第i小元素，k为A[p,q]元素个数（小于主元的L array）<br>37         return A[q];//k i 也行？: 不行以0起始<br>38     if (i &lt; k) 39         return Randomized_Select(A, p, q - 1, i); 40     else<br>41         return Randomized_Select(A, q + 1, r, i); 42<br>43 } 44 int Randomized_Select(std::vector&lt;int&gt;&amp; A, const int i) 45 { 46     int r = A.size() - 1; 47     return Randomized_Select(A, 0, r, i); 48 }</p><!-- more -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MAX_MIN</title>
      <link href="/2020/10/24/max-min/"/>
      <url>/2020/10/24/max-min/</url>
      
        <content type="html"><![CDATA[<p>代码太烂：不简洁&nbsp;</p><p> 1 #pragma once<br> 2 /*<br> 3 事实上，我们只需要最多3 Ln/2」次比较就可以同时找到最小值和最大值。具体的方法是记<br> 4 录已知的最小值和最大值。但我们并不是将每一个输入元素与当前的最小值和最大值进行比<br> 5 团丑较这样做的代价是每个元素需要2次比较，而是对输入元素成对地进行处理。首先，我们将<br> 6 一对输入元素相互进行比较，然后把较小的与当前最小值比较，把较大的与当前最大值进行比<br> 7 较。这样，对每两个元素共需3 次比较。<br> 8 如何设定已知的最小值和最大值的初始值依赖千n是奇数还是偶数。如果n是奇数，我们就<br> 9 将最小值和最大值的初值都设为第一个元素的值，然后成对地处理余下的元素。如果n是偶数， 10 就对前两个元素做一次比较，以决定最小值和最大值的初值，然后与n是奇数的情形一样，成对 11 地处理余下的元素。 12 */<br>13 #include 14 #include //pair<br>15<br>16 std::pair&lt;int,int&gt;<br>17 max_min(const std::vector&lt;int&gt;&amp; A) 18 { 19     //奇数<br>20     if (A.size() &amp; 1) 21 { 22         int max= A[0], min = A[0]; 23         for (int i = 1; i != A.size() - 1;++i) 24 { 25             if (A[i] &lt; A[i + 1]) 26 { 27                 if (A[i] &lt; min) 28                     min = A[i]; 29                 if (max &lt; A[i + 1]) 30                     max = A[i + 1]; 31 } 32             else<br>33 { 34                 if (A[i + 1] &lt; min) 35                     min = A[i + 1]; 36                 if (max &lt; A[i]) 37                     max = A[i]; 38 } 39 } 40         return { min,max }; 41 } 42     //偶数<br>43     else<br>44 { 45         int min = A[0],max = A[1]; 46         if (A[1] &lt; A[0]) 47             min = A[1], max = A[0]; 48         for (int i = 2; i != A.size() - 1;++i) 49 { 50             if (A[i] &lt; A[i + 1]) 51 { 52                 if (A[i] &lt; min) 53                     min = A[i]; 54                 if (max &lt; A[i + 1]) 55                     max = A[i + 1]; 56 } 57             else<br>58 { 59                 if (A[i + 1] &lt; min) 60                     min = A[i + 1]; 61                 if (max &lt; A[i]) 62                     max = A[i]; 63 } 64 } 65         return { min,max }; 66 } 67 }</p><!-- more -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>#include&quot;RADIX_SORT_GET_WZ.h&quot;</title>
      <link href="/2020/10/22/include-radix-sort-get-wz-h/"/>
      <url>/2020/10/22/include-radix-sort-get-wz-h/</url>
      
        <content type="html"><![CDATA[<p>#pragma once #include #include #include&lt;string&gt; #include //stringstream<br>#include //setw setfill //内置变量pass-by-value more than pass-by-reference ? //P12 –Effective C++(Chinese) //d位数，A数字<br>int get_d(const std::vector&lt;int&gt;&amp; A)<br>{ int max = *std::max_element(A.cbegin(), A.cend()); int d = 0; for (int i = max; i != 0;d++)<br>    {<br>        i /= 10;<br>    } return d;<br>} int get_ws(const std::vector&lt;int&gt;&amp; A, int j,int ws)<br>{ int d = get_d(A);<br>    auto s = std::to_string(A[j]);<br>    std::stringstream ss;<br>    ss &lt;&lt; std::left &lt;&lt; std::setfill(‘0’) &lt;&lt; std::setw(d + 1) &lt;&lt; s;<br>    s = ss.str();<br>    ss &lt;&lt; std::right &lt;&lt; std::setfill(‘ ‘); int k = s[ws] - ‘0’; return k;<br>} //k:A数组中最大值，ws： 对A的的第几位排序 A[ws]<br>void Count_sort_wz(std::vector&lt;int&gt;&amp; A, int ws)<br>{ // ws = pow(10, ws);<br>    std::vector&lt;int&gt; c(10); for (int j = 0;j != A.size();++j) ++c[get_ws(A,j,ws)]; for (int i = 1;i &lt;= 10;++i)<br>        c[i] += c[i - 1];<br>    std::vector&lt;int&gt; b(A.size()); for (int i = A.size() - 1;i &gt;= 0;–i)<br>        b[--c[get_ws(A,i,ws)]] = A[i]; for (int i = 0; i != A.size();++i)<br>        A[i] = b[i];<br>} void Radix_Sort(std::vector&lt;int&gt;&amp; A)<br>{ int max = *std::max_element(A.cbegin(), A.cend()); int d = get_d(A); for (int ws = 0;ws != d; ++ws)<br>    { //max 这时为0<br> Count_sort_wz(A, ws);<br>    }<br>}</p><p>参考</p><p><a href="https://www.cnblogs.com/hellowooorld/p/7810849.html">int转成string的同时加上前缀0</a></p><p><a href="https://stackoverflow.com/questions/21270162/cannot-convert-a-character-string-to-int">convert char to int</a></p><!-- more -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Radix_Sort C++</title>
      <link href="/2020/10/22/radix-sort-c/"/>
      <url>/2020/10/22/radix-sort-c/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zh.wikipedia.org/wiki/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><strong>基数排序</strong></a>（英语：Radix sort）是一种非比较型<a href="https://zh.wikipedia.org/wiki/%E6%95%B4%E6%95%B0" title="整数">整数</a><a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95" title="排序算法">排序算法</a>，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。基数排序的发明可以追溯到1887年<a href="https://zh.wikipedia.org/wiki/%E8%B5%AB%E7%88%BE%E6%9B%BC%C2%B7%E4%BD%95%E6%A8%82%E7%A6%AE" title="赫尔曼·何乐礼">赫尔曼·何乐礼</a>在<a href="https://zh.wikipedia.org/w/index.php?title=%E6%89%93%E5%AD%94%E5%8D%A1%E7%89%87%E5%88%B6%E8%A1%A8%E6%9C%BA&amp;action=edit&amp;redlink=1" title="打孔卡片制表机（页面不存在）">打孔卡片制表机</a>（Tabulation Machine）上的贡献<a href="https://zh.wikipedia.org/wiki/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F#cite_note-1">[1]</a>。</p><p>它是这样实现的：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列</p><p><img src="https://img2020.cnblogs.com/blog/2092141/202010/2092141-20201022175610056-2109717260.gif"></p><p><a href="https://zh.wikipedia.org/wiki/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F">Wiki</a></p><p><img src="https://img2020.cnblogs.com/blog/2092141/202010/2092141-20201022175909934-947249499.png"></p><p><a href="https://www.programiz.com/dsa/radix-sort">process</a></p><p>对于取位数上的值：</p><ul><li>  创建vector&gt; 处理A 变为 A[值][位数值] ：例如：A[6] = 789, A[6][1] = 8&nbsp; &nbsp; &nbsp; &nbsp; : 需要内存多 而且效率低 但是模块化 </li><li>  将 vector 变为str 在用str的下标得到位数值 转变int ：stoi(to_string(A[i])[ws]) : 会超出索引。 例如最大值为3位 而其中一个位1位数，当A[i][1] 为‘\0’空字符 <a href="https://www.cnblogs.com/Z-s-c11/p/13861138.html">需要另外处理</a></li><li>/ %这个方法： 看起来不c++ 但确实好用  (A[i] / ws) % 10  CODE C++</li></ul><p> 1 #pragma once<br> 2 #include 3 #include 4 #include&lt;string&gt;<br> 5 //内置变量pass-by-value more than pass-by-reference ?<br> 6 //P12 –Effective C++(Chinese)<br> 7<br> 8<br> 9 //k:A数组中最大值，ws： 对A的的第几位排序 A[ws]<br>10 void Count_sort_wz(std::vector&lt;int&gt;&amp; A,int ws) 11 { 12     ws = pow(10, ws); 13     std::vector&lt;int&gt; c(10); 14     for (int j = 0;j != A.size();++j) 15 { 16         //++c[(A[i] / ws) % 10] 17         //cant stoi(char) 18         //++c[(std::to_string(A[j])[ws])-‘0’];<br>19         ++c[(A[j] / ws) % 10]; 20 } 21     for (int i = 1;i != 10;++i) 22         c[i] += c[i - 1]; 23     std::vector&lt;int&gt; b(A.size()); 24     for (int i = A.size() - 1;i &gt;= 0;–i) 25         b[–c[(A[i] / ws) % 10]] = A[i]; 26     for (int i = 0; i != A.size();++i) 27         A[i] = b[i]; 28 } 29<br>30 //d位数，A数字<br>31 void Radix_Sort(std::vector&lt;int&gt;&amp; A) 32 { 33     int max = *std::max_element(A.cbegin(), A.cend()); 34     int d = 0; 35     for(int i = max; i !=0;d++ ) 36 { 37         i /= 10; 38 } 39     for (int ws = 0;ws != d; ++ws) 40 { 41         //max 这时为0<br>42 Count_sort_wz(A, ws); 43 } 44 }</p><!-- more -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Count_sort C++</title>
      <link href="/2020/10/18/count-sort-c/"/>
      <url>/2020/10/18/count-sort-c/</url>
      
        <content type="html"><![CDATA[<p>简介：<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F">Wiki</a></p><p>通俗地理解，例如有10个年龄不同的人，统计出有8个人的年龄比A小，那A的年龄就排在第9位，用这个方法可以得到其他每个人的位置，也就排好了序。当然，年龄有重复时需要特殊处理（保证稳定性），这就是为什么最后要反向填充目标数组，以及将每个数字的统计减去1。算法的步骤如下：</p><ol><li> 找出待排序的数组中最大和最小的元素</li><li> 统计数组中每个值为{\displaystyle i}<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/add78d8608ad86e54951b8c8bd6c8d8416533d20" alt="i">的元素出现的次数，存入数组{\displaystyle C}<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4fc55753007cd3c18576f7933f6f089196732029" alt=" C ">的第{\displaystyle i}<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/add78d8608ad86e54951b8c8bd6c8d8416533d20" alt="i">项</li><li> 对所有的计数累加（从{\displaystyle C}<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4fc55753007cd3c18576f7933f6f089196732029" alt=" C ">中的第一个元素开始，每一项和前一项相加）</li><li> 反向填充目标数组：将每个元素{\displaystyle i}<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/add78d8608ad86e54951b8c8bd6c8d8416533d20" alt="i">放在新数组的第{\displaystyle C[i]}<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/d9e670bd48c5b92b5228727d2a35097581cc85a6" alt="{\displaystyle C[i]}">项，每放一个元素就将{\displaystyle C[i]}<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/d9e670bd48c5b92b5228727d2a35097581cc85a6" alt="{\displaystyle C[i]}">减去1</li></ol><p>计数</p><p><img src="https://img2020.cnblogs.com/blog/2092141/202010/2092141-20201018211257389-1786086949.png"></p><p>加总</p><p><img src="https://img2020.cnblogs.com/blog/2092141/202010/2092141-20201018211507923-461663628.png"></p><p>&nbsp;<img src="https://img2020.cnblogs.com/blog/2092141/202010/2092141-20201018211535057-1729796635.png"></p><p>//对每个A[i]值来说，C[A[i]]就是A[i]在输出数组中的最终正确位置（从1起）<br>//因为有相等元素，所以C[A[i]]的值减1：所以具有稳定性<br>//稳定性：对两个相同的数来说，在输入数组中先出现的数，在输出数组中也在前面</p><p><a href="https://www.programiz.com/dsa/counting-sort">这个图片更直观些</a></p><p><img src="https://img2020.cnblogs.com/blog/2092141/202010/2092141-20201018211952816-2067026309.png"></p><p>&nbsp;c++ code</p><p> 1 #pragma once<br> 2 #include 3 //当k = O(n)时，采用计数排序，运行时间theta(n)<br> 4 //theta(k)+theta(n)+theta(k)+theta(n)=theta(n)<br> 5 std::vector&lt;int&gt;<br> 6 Count_sort(const std::vector&lt;int&gt;&amp; A, const int&amp; k) 7 {<br> 8     std::vector&lt;int&gt; c(k + 1);<br> 9     //计数:theta(k)<br>10     for (int j = 0;j != A.size(); ++j) 11         ++c[A[j]]; 12     //加总:theta(n)<br>13     for (int i = 1;i &lt;= k;++i) 14         c[i] += c[i - 1]; 15     //布置:theta(k)<br>16     std::vector&lt;int&gt; b(A.size()); 17     //:theta(n)<br>18     for (int i = A.size()-1; i &gt;= 0;–i) 19         //对每个A[i]值来说，C[A[i]]就是A[i]在输出数组中的最终正确位置（从1起） 20         //因为有相等元素，所以C[A[i]]的值减1：所以具有稳定性 21         //稳定性：对两个相同的数来说，在输入数组中先出现的数，在输出数组中也在前面<br>22         b[–c[A[i]]] = A[i]; 23     return b; 24 }</p><p>main.cpp</p><p> 1 #include 2 #include 3 #include //ostream_iterator<br> 4 #include”COUNTING_SORT.h”<br> 5<br> 6 using namespace std; 7<br> 8 void print(const vector&lt;int&gt;&amp; v) 9 { 10     ostream_iterator&lt;int&gt; out_iter(cout, “ “); 11 copy(v.cbegin(), v.cend(), out_iter); 12     cout &lt;&lt; endl; 13 } 14 void CountingSort() 15 { 16     vector&lt;int&gt; v = { 2,5,3,0,2,3,0,3 }; 17 print(v); 18     print(Count_sort(v, *max_element(v.cbegin(), v.cend()))); 19 } 20 int main() 21 { 22 CountingSort(); 23 }</p><!-- more -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Priority_Queue C++</title>
      <link href="/2020/10/18/priority-queue-c/"/>
      <url>/2020/10/18/priority-queue-c/</url>
      
        <content type="html"><![CDATA[<p><strong><a href="https://zh.wikipedia.org/wiki/%E5%84%AA%E5%85%88%E4%BD%87%E5%88%97">优先队列</a>:</strong></p><p>是<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6" title="计算机科学">计算机科学</a>中的一类<a href="https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E6%95%B8%E6%93%9A%E9%A1%9E%E5%9E%8B" title="抽象数据类型">抽象数据类型</a>。优先队列中的每个元素都有各自的优先级，优先级最高的元素最先得到服务；优先级相同的元素按照其在优先队列中的顺序得到服务。优先队列往往用**<a href="https://zh.wikipedia.org/wiki/%E5%A0%86_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)" title="堆 (数据结构)">堆</a>**来实现。</p><p> 1 #pragma once<br> 2 #include 3 #include//runtime_error<br> 4 #include 5 <a href="https://www.cnblogs.com/Z-s-c11/p/13832703.html">#include”HEAPSORT.h”</a><br> 6<br> 7 int Heap_Maximum(std::vector&lt;int&gt;&amp; A) 8 {<br> 9     return A[0]; 10 } 11<br>12<br>13 //取最大值并删除<br>14 int Heap_Extract_Max(std::vector&lt;int&gt;&amp; A) 15 { 16     heap_size = A.size() - 1; 17 Build_Max_Heap(A); 18     /*<br>19 try 20 { 21 if (heap_size &lt; 0) 22 throw std::runtime_error(“heap underflow”); 23 } 24 catch (std::runtime_error err) 25 { 26 std::cout &lt;&lt; err.what() 27 &lt;&lt; “\n Try Again? Enter y or n” &lt;&lt; std::endl; 28 char c; 29 std::cin &gt;&gt; c; 30 if (!std::cin || c == ‘n’) 31 return -1; 32 } 33     */<br>34     if (heap_size &lt; 0) 35         throw std::runtime_error(“heap underflow”); 36     int max = A[0]; 37     A[0] = A[heap_size]; 38     –heap_size; 39     Max_Heapify(A, 0); 40     return max; 41 } 42 //改变(变大)节点里面的值<br>43 void Heap_Increase_Key(std::vector&lt;int&gt;&amp; A, int&amp; i, const int&amp; key) 44 { 45     if (key &lt; A[i]) 46         throw std::runtime_error(“new key is small than current key”); 47     A[i] = key; 48     //保持最大堆<br>49     while (i &gt; 0 &amp;&amp; A[parent(i)] &lt; A[i]) 50 { 51 std::swap(A[i], A[parent(i)]); 52         i = parent(i); 53 } 54 } 55 //在末尾处插入键值<br>56 void Max_Heap_Insert(std::vector&lt;int&gt;&amp; A, const int&amp; key) 57 { 58     ++heap_size; 59     A[heap_size] = INT_MIN; 60 Heap_Increase_Key(A, heap_size, key); 61 }</p><p>main.cpp</p><p> 1 #include 2 #include //ostream_iterator<br> 3 #include”PRIORITY_QUEUE.h”<br> 4 using namespace std; 5 void print(vector&lt;int&gt;&amp; v) 6 {<br> 7     ostream_iterator&lt;int&gt; out_iter(cout, “ “);<br> 8     copy(v.begin(), v.end(), out_iter);<br> 9 } 10 void Priority_Queue() 11 { 12     vector&lt;int&gt; v = { 4,1,3,2,16,9,10,14,8,7 }; 13 print(v); 14     cout &lt;&lt; endl; 15     cout &lt;&lt; Heap_Extract_Max(v) &lt;&lt; endl; 16     Max_Heap_Insert(v, 15); 17     cout&lt; endl;<br>18 HeapSort(v); 19 print(v); 20 } 21 int main() 22 { 23 Priority_Queue(); 24 }</p><!-- more -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>static全局变量与普通的全局变量（转载）</title>
      <link href="/2020/10/18/static-quan-ju-bian-liang-yu-pu-tong-de-quan-ju-bian-liang-zhuan-zai/static-quan-ju-bian-liang-yu-pu-tong-de-quan-ju-bian-liang-zhuan-zai/"/>
      <url>/2020/10/18/static-quan-ju-bian-liang-yu-pu-tong-de-quan-ju-bian-liang-zhuan-zai/static-quan-ju-bian-liang-yu-pu-tong-de-quan-ju-bian-liang-zhuan-zai/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/weiyuefei/article/details/51563890">https://blog.csdn.net/weiyuefei/article/details/51563890</a></p><p>写的清楚 就是不知道出处在哪 看到全是转载也不贴原址</p><p>一、程序的内存分配</p><p>一个由C/C++编译的程序占用的内存分为以下几个部分：</p><p>1、栈区（stack）—&nbsp;由编译器自动分配释放&nbsp;，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</p><p>2、堆区（heap）&nbsp;—&nbsp;一般由程序员分配释放，&nbsp;若程序员不释放，程序结束时可能由OS回收&nbsp;。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。</p><p>3、全局区（静态区）（static）— 全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，&nbsp;未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后有系统释放</p><p>4、文字常量区&nbsp;—&nbsp;常量字符串就是放在这里的。&nbsp;程序结束后由系统释放。</p><p>5、程序代码区 —&nbsp;存放函数体的二进制代码。</p><p>二、例子程序</p><p>&nbsp;//main.cpp</p><p>&nbsp;int a = 0;&nbsp;全局初始化区</p><p>&nbsp;char *p1;&nbsp;全局未初始化区</p><p>&nbsp;main()</p><p>&nbsp;{</p><p>&nbsp;int b;//&nbsp;栈</p><p>&nbsp;char s[] = “abc”; //栈</p><p>&nbsp;char *p2; //栈</p><p>&nbsp;char *p3 = “123456”; 123456\0”;//在常量区，p3在栈上。</p><p>&nbsp;static int c =0；&nbsp;//全局（静态）初始化区</p><p>&nbsp;p1 = (char *)malloc(10);</p><p>&nbsp;p2 = (char *)malloc(20);</p><p>&nbsp;//分配得来得10和20字节的区域就在堆区。</p><p>&nbsp;strcpy(p1, “123456”); //123456\0放在常量区，编译器可能会将它与p3所指向的”123456”优化成一个地方。</p><p>&nbsp;}</p><p>三、从作用域看：  </p><p>全局变量具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包含全局变量定义的源文件需要用extern 关键字再次声明这个全局变量。  </p><p>局部变量也只有局部作用域，它是自动对象（auto），它在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回。</p><p>静态局部变量具有局部作用域，它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在，它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。  </p><p>静态全局变量也具有全局作用域，它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被static关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。  </p><p>从分配内存空间看：<br>全局变量，静态局部变量，静态全局变量都在静态存储区分配空间，而局部变量在栈里分配空间。</p><p>从以上分析可以看出， 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。因此static&nbsp;这个说明符在不同的地方所起的作用是不同的。  </p><p>四、总的来说就是：  </p><p>1、生存周期不同<br>2、作用范围不同<br>3、分配方式不同</p><p>-———————————————</p><p>再来看下堆和栈的不同：</p><p>1、分配方式不同；<br>2、空间大小不同；<br>3、分配效率不同；<br>4、能否产生碎片不同；<br>5、生长方向不同；</p><p>1、分配方式不同</p><p>栈:<br>由系统自动分配。 例如，声明在函数中一个局部变量 int b; 系统自动在栈中为b开辟空间<br>堆:<br>需要程序员自己申请，并指明大小，在c中malloc函数<br>如p1 = (char *)malloc(10);<br>在C++中用new运算符<br>如p2 = (char *)new(10);<br>但是注意p1、p2本身是在栈中的。&nbsp;  </p><p>2、&nbsp;空间大小不同  </p><p>一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M。  </p><p>3、分配效率  </p><p>栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执 行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考 数据结构/操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。  </p><p>4、碎片问题  </p><p>栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。&nbsp;<br>堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，&nbsp;<br>会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。&nbsp;  </p><p>对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出。  </p><p>5、生长方向&nbsp;  </p><p>对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。&nbsp;  </p><p>堆和栈相比，由于大量new/delete的使用，容易造成大量的内存碎片；由于没有专门的系统支持，效率很低；由于可能引发用户态和核心态的切换，内存的申请，代价变得更加昂贵。所以栈在程序中是应用最广泛的，就算是函数的调用也利用栈去完成，函数调用过程中的参数，返回地址，EBP和局部变量都采用栈的方式存放。所以，我们推荐大家尽量用栈，而不是用堆。虽然栈有如此众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，还是用堆好一些。&nbsp;</p><h1 id="static函数与普通函数有什么区别"><a href="#static函数与普通函数有什么区别" class="headerlink" title="static函数与普通函数有什么区别"></a>static函数与普通函数有什么区别</h1><p>　用static修饰的函数，本限定在本源码文件中，不能被本源码文件以外的代码文件调用。而普通的函数，默认是extern的，也就是说，可以被其它代码文件调用该函数。<br>　　在函数的返回类型前加上关键字static，函数就被定义成为静态函数。普通 函数的定义和声明默认情况下是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。因此定义静态函数有以下好处：<br>　　&lt;1&gt; 其他文件中可以定义相同名字的函数，不会发生冲突。<br>　　&lt;2&gt; 静态函数不能被其他文件所用。</p><p>static全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？ 　　<br>答:  </p><ol><li>全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。这两者的区别在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用， 因此可以避免在其它源文件中引起错误。 　　  </li><li>从以上分析可以看出， 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。　　&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </li><li>static函数与普通函数作用域不同,仅在本文件。只在当前源文件中使用的函数应该说明为内部函数(static)，内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件 　　<br>综上所述:<br>static全局变量与普通的全局变量有什么区别：<br>static全局变量只初使化一次，防止在其他文件单元中被引用; 　　<br>static局部变量和普通局部变量有什么区别：<br>static局部变量只被初始化一次，下一次依据上一次结果值； 　　<br>static函数与普通函数有什么区别：<br>static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝<!-- more --></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HeapSort C++</title>
      <link href="/2020/10/17/heapsort-c/"/>
      <url>/2020/10/17/heapsort-c/</url>
      
        <content type="html"><![CDATA[<h2 id="from-Wiki"><a href="#from-Wiki" class="headerlink" title="from Wiki"></a>from Wiki</h2><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>若以升序排序说明，把<a href="https://zh.wikipedia.org/wiki/%E9%99%A3%E5%88%97" title="数组">数组</a>转换成<a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E5%A4%A7%E2%80%94%E6%9C%80%E5%B0%8F%E5%A0%86" title="最大—最小堆">最大堆</a>(Max-Heap Heap)，这是一种满足最大堆性质(Max-Heap Property)的<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%A8%B9" title="二叉树">二叉树</a>：对于除了根之外的每个节点i, A[parent(i)] ≥ A[i]。</p><p>重复从最大堆取出数值最大的结点(把根结点和最后一个结点交换，把交换后的最后一个结点移出堆)，并让残余的<a href="https://zh.wikipedia.org/wiki/%E5%A0%86%E7%A9%8D" title="堆">堆</a>维持最大堆性质。</p><h2 id="堆节点的访问"><a href="#堆节点的访问" class="headerlink" title="堆节点的访问"></a>堆节点的访问</h2><p>通常堆是通过一维<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E7%BB%84" title="数组">数组</a>来实现的。在数组起始位置为0的情形中：</p><ul><li>  父节点i的左子节点在位置<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/3bff8f7d580269fe6c1e35648032bf2b93354088" alt="{\displaystyle (2i+1)}">;</li><li>  父节点i的右子节点在位置<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e14787fdbf6c5580fcd2cf9f63c21dbeb8d82f5e" alt="{\displaystyle (2i+2)}">;</li><li>  子节点i的父节点在位置<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f38b28cfa0a788a6d767061ab7481da190b339b6" alt="{\displaystyle floor((i-1)/2)}">;</li></ul><p><a href="https://www.programiz.com/dsa/heap-sort">Max_Heapify</a></p><p><img src="https://img2020.cnblogs.com/blog/2092141/202010/2092141-20201017214936454-1159612428.png"></p><h2 id="Build-max-heap"><a href="#Build-max-heap" class="headerlink" title="Build max-heap"></a>Build max-heap</h2><p>算法导论 P89</p><p><img src="https://img2020.cnblogs.com/blog/2092141/202010/2092141-20201017215232892-1158735924.png"></p><p>&nbsp;<img src="https://img2020.cnblogs.com/blog/2092141/202010/2092141-20201017215259916-1425206893.png"></p><p>#include”HEAPSORT”.h</p><p> 1 #pragma once<br> 2 #include 3 //全局静态变量<br> 4 //它与全局变量的区别在于如果程序包含多个文件的话，<br> 5 //它作用于定义它的文件里，不能作用到其它文件里，<br> 6 //即被static关键字修饰过的变量具有文件作用域。<br> 7 //这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。<br> 8 static int heap_size; 9<br>10 //近似完全二叉树：节点i的父节点、左孩子、右孩子 11 //默认向偶数(向下）取整 —-《深入理解计算机系统》 12 //以0起始数组<br>13 int parent(const int&amp; i) 14 { 15     return (i - 1) / 2; 16 } 17 int left(const int&amp; i) 18 { 19     return 2 * i + 1; 20 } 21 int right(const int&amp; i) 22 { 23     return 2 * i + 2; 24 } 25 //化为最大堆：父节点&gt;左孩子&gt;右孩子   i为父节点<br>26 void Max_Heapify(std::vector&lt;int&gt;&amp; A, const int&amp; i) 27 { 28     int l = left(i); 29     int r = right(i); 30     int largest; 31     //寻找该节点结构(父、左、右)中最大值<br>32     if (l &lt;= heap_size &amp;&amp; A[i] &lt; A[l]) 33         largest = l; 34     else<br>35         largest = i; 36     if (r &lt;= heap_size &amp;&amp; A[largest] &lt; A[r]) 37         largest = r; 38     //使最大值为父节点<br>39     if (largest != i) 40 { 41 std::swap(A[i], A[largest]); 42         //使被交换的结点结构也是最大堆<br>43 Max_Heapify(A, largest); 44 } 45 } 46<br>47 //建堆:从下到上<br>48 void Build_Max_Heap(std::vector&lt;int&gt;&amp; A) 49 { 50     // A[n/2]+1+…+n都是含有孩子的父节点<br>51     for (int i = (A.size()-1) / 2; i &gt;= 0;–i) 52 Max_Heapify(A, i); 53 } 54<br>55 void HeapSort(std::vector&lt;int&gt;&amp; A) 56 { 57     heap_size = A.size() - 1; 58 Build_Max_Heap(A); 59     //倒数第二个最大堆化：这时就剩下根节点A[0]和该节点i 再次进行最大堆后顺序已定<br>60     for (int i = A.size() - 1; i != 0;–i) 61 { 62         std::swap(A[0], A[i]);//最大堆化后A[i]为最大值 :排在末尾<br>63         –heap_size; 64         Max_Heapify(A, 0); 65 } 66 }</p><p>main.cpp</p><p>#include #include //ostream_iterator<br>#include”HEAPSORT.h”<br>using namespace std; void print(vector&lt;int&gt;&amp; v)<br>{<br>    ostream_iterator&lt;int&gt; out_iter(cout, “ “);<br>    copy(v.begin(), v.end(), out_iter);<br>} void HeapSort()<br>{<br>    vector&lt;int&gt; v = {4,1,3,2,16,9,10,14,8,7};<br>    print(v);<br>    cout &lt;&lt; endl;<br>    HeapSort(v);<br>    cout &lt;&lt; “heap_soted: “ &lt;&lt; endl;<br>    print(v);<br>} int main()<br>{<br>    HeapSort();<br>}</p><!-- more -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Randomized_QuickSort C++</title>
      <link href="/2020/10/17/randomized-quicksort-c/"/>
      <url>/2020/10/17/randomized-quicksort-c/</url>
      
        <content type="html"><![CDATA[<p>算法导论(第三版)中文 P102</p><p><img src="https://img2020.cnblogs.com/blog/2092141/202010/2092141-20201017174749190-1759871966.png"></p><p>&nbsp;<img src="https://img2020.cnblogs.com/blog/2092141/202010/2092141-20201017174925456-2129512644.png"></p><p> //RANDOMIZED_QUICKSORT.h文件  </p><p> 1 #pragma once<br> 2 #include”QUICKSORT.h”<br> 3 #include 4 #include 5 int Randomized_partition(std::vector&lt;int&gt;&amp; A, const int&amp; p, const int&amp; r) 6 {<br> 7     std::default_random_engine e; //引擎：生成随机无符号数<br> 8     std::uniform_int_distribution u(p, r);// 范围内的随机数<br> 9     int i = u(e); 10     std::swap(A[r], A[i]); //是随机数是主元<br>11     return Partition(A, p, r); 12 } 13<br>14 void Randomized_QuickSort(std::vector&lt;int&gt; &amp;A, const int&amp; p, const int&amp; r) 15 { 16     if (p &lt; r) 17 { 18         int q = Randomized_partition(A, p, r); 19         Randomized_QuickSort(A, p, q-1); 20         Randomized_QuickSort(A, q + 1, r); 21 } 22 }</p><p>main.cpp</p><p> 1 #include”QUICKSORT.h”<br> 2 #include”RANDOMIZED_QUICKSORT.h”<br> 3 #include //ostream_iterator<br> 4 void QuickSort() 5 {<br> 6     vector&lt;int&gt; v = { 0,2,8,7,1,3,5,6 };//0 占位置 是 i = p-1;<br> 7     cout &lt;&lt; “A is” &lt;&lt; endl; 8     std::ostream_iterator&lt;int&gt; out_iter(cout, “ “);<br> 9     copy(v.begin() + 1, v.end(), out_iter); 10     cout &lt;&lt; endl; 11     Randomized_QuickSort(v, 1, v.size()-1); 12     cout &lt;&lt; “ sorted A “ &lt;&lt; endl; 13     copy(v.begin() + 1, v.end(), out_iter); 14 } 15 int main() 16 { 17 QuickSort(); 18 }</p><!-- more -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>QuickSort c++</title>
      <link href="/2020/10/15/quicksort-c/"/>
      <url>/2020/10/15/quicksort-c/</url>
      
        <content type="html"><![CDATA[<h2 id="QuickSort-c"><a href="#QuickSort-c" class="headerlink" title="QuickSort c++"></a>QuickSort c++</h2><p>简介 算法导论<br><img src="https://img-blog.csdnimg.cn/20201015213546558.png#pic_center" alt="在这里插入图片描述"></p><p>原理 from Wiki<br><img src="https://img-blog.csdnimg.cn/20201015210913175.gif#pic_center" alt="Wiki"><br><img src="https://img-blog.csdnimg.cn/20201015211154471.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3o5NzQ4OTA4Njk=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>非常快的排序算法：</p><p><strong>划分两个子数组后 两个子数组之间不会进行比较 比较次数减少 所以算法变快</strong></p><p>只要划分常数比例，算法的运行时间 ： theta(nlgn);</p><p>执行顺序：<br><strong>左侧排序完 在执行右侧</strong></p><p>实验结果：<br><img src="https://img-blog.csdnimg.cn/20201015211839322.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3o5NzQ4OTA4Njk=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>C++ code</strong><br>#include”QUICKSORT.h”</p><pre><code class="cpp">#pragma once#includeint Partition(std::vector&lt;int&gt;&amp; A, const int&amp; p, const int&amp; r){    int x = A[r];    int i = p - 1; //断点    for (auto j = p;j != r;++j)    {        if (A[j] &lt;= x)        {            ++i;            std::swap(A[i], A[j]);        }    }    std::swap(A[i + 1], A[r]);    return i + 1;}void QuickSort(std::vector&lt;int&gt;&amp; A, const int&amp; p, const int&amp; r){    if (p &lt; r)    {        int q = Partition(A, p, r);        QuickSort(A, p, q - 1); //QL        QuickSort(A, q + 1, r); //QR    }}</code></pre><p>main.cpp</p><pre><code class="cpp">#include"QUICKSORT.h"#include //ostream_iteratorvoid QuickSort(){    vector&lt;int&gt; v = { 0,2,8,7,1,3,5,6 };//0 占位置 是 i = p-1;    cout &lt;&lt; "A is" &lt;&lt; endl;    std::ostream_iterator&lt;int&gt; out_iter(cout, " ");    copy(v.begin() + 1, v.end(), out_iter);    cout &lt;&lt; endl;    QuickSort(v, 1, v.size()-1);    cout &lt;&lt; " sorted A " &lt;&lt; endl;    copy(v.begin() + 1, v.end(), out_iter);}int main(){    QuickSort();}</code></pre><!-- more -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Find_Maximum_Subarray C++</title>
      <link href="/2020/10/14/find-maximum-subarray-c/"/>
      <url>/2020/10/14/find-maximum-subarray-c/</url>
      
        <content type="html"><![CDATA[<h2 id="Find-Maximum-Subarray"><a href="#Find-Maximum-Subarray" class="headerlink" title="Find_Maximum_Subarray"></a>Find_Maximum_Subarray</h2><p>最大子数组一定在三种情况中：<br>A[low,mid] , A[mid+1,high] ,A[i,j]<br><img src="https://img-blog.csdnimg.cn/20201014182451879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3o5NzQ4OTA4Njk=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>Divide:<br>2分方式：</p><pre><code class="cpp">if (low == high)        return { low,high,A[low] };    else    {        int mid = (low + high) / 2;        //vec_f = left_low,left_high,left_sum        auto vec_f = Find_Maximum_Subarray(A, low, mid);        //vec_r = right_low,right_high,right_sum        auto vec_r = Find_Maximum_Subarray(A, mid + 1, high);</code></pre><p><img src="https://img-blog.csdnimg.cn/20201014182322297.png#pic_center" alt="在这里插入图片描述"><br>Conquer:<br>子问题找最大数组：<br>[i,j] 可以是 [low,mid], [mid+1,high]</p><pre><code class="cpp">std::vector&lt;int&gt; // v.front() = max_left,v[1]= max_right,v.back()=left_sum + right_sumFind_Max_Crossing_Subarray(std::vector&lt;int&gt; A, int low, int mid, int high){    int left_sum = INT_MIN;    int sum = 0,max_left = mid, max_right=mid;    for (auto i = mid; i &gt;= low;--i)    {        sum += A[i];        if (sum &gt; left_sum)        {            left_sum = sum;            max_left = i;        }    }    int right_sum = INT_MIN;    sum = 0;    for (auto j = mid + 1;j &lt;= high;++j)    {        sum += A[j];        if (sum &gt; right_sum)        {            right_sum = sum;            max_right = j;        }    }    return { max_left,max_right,left_sum + right_sum };}</code></pre><p>最后找到三者中最大的</p><pre><code class="cpp">if ((vec_f.back() &gt;= vec_r.back()) &amp;&amp; (vec_f.back() &gt;= vec_c.back()))            return { vec_f[0],vec_f[1],vec_f[2] };        if ((vec_r.back() &gt;= vec_f.back()) &amp;&amp; (vec_r.back() &gt;= vec_c.back()))            return { vec_r[0],vec_r[1],vec_r[2] };        else             return { vec_c[0],vec_c[1],vec_c[2] };</code></pre><p>c++ code<br>#include”FIND_MAXIMUM_SUBARRAY .h”</p><pre><code class="cpp">#pragma once#include#include#includestd::vector&lt;int&gt; // v.front() = max_left,v[1]= max_right,v.back()=left_sum + right_sumFind_Max_Crossing_Subarray(const std::vector&lt;int&gt; &amp;A,const int &amp;low,const int &amp;mid,const int &amp;high){    int left_sum = INT_MIN;    int sum = 0,max_left = mid, max_right=mid;    for (auto i = mid; i &gt;= low;--i)    {        sum += A[i];        if (sum &gt; left_sum)        {            left_sum = sum;            max_left = i;        }    }    int right_sum = INT_MIN;    sum = 0;    for (auto j = mid + 1;j &lt;= high;++j)    {        sum += A[j];        if (sum &gt; right_sum)        {            right_sum = sum;            max_right = j;        }    }    return { max_left,max_right,left_sum + right_sum };}std::vector&lt;int&gt; //v.front() = low ,v[1] = high, v.back() = sum;Find_Maximum_Subarray(const std::vector&lt;int&gt; &amp;A,const int low,const int high){    //一用Divide方式 ：带入子问题的下标(范围)    if (low == high)        return { low,high,A[low] };    else    {        int mid = (low + high) / 2;        //vec_f = left_low,left_high,left_sum        auto vec_f = Find_Maximum_Subarray(A, low, mid);        //vec_r = right_low,right_high,right_sum        auto vec_r = Find_Maximum_Subarray(A, mid + 1, high);        //Conquer部分：如何解决子问题        //vec_c = cross_low,cross_high,cross_sum        auto vec_c = Find_Max_Crossing_Subarray(A, low, mid, high);        //子问题的答案如何让处理： 不影响每次带入Find_c 的下标        if ((vec_f.back() &gt;= vec_r.back()) &amp;&amp; (vec_f.back() &gt;= vec_c.back()))            return { vec_f[0],vec_f[1],vec_f[2] };        if ((vec_r.back() &gt;= vec_f.back()) &amp;&amp; (vec_r.back() &gt;= vec_c.back()))            return { vec_r[0],vec_r[1],vec_r[2] };        else             return { vec_c[0],vec_c[1],vec_c[2] };    }}</code></pre><p>main.cpp</p><pre><code class="cpp">#include"FIND_MAXIMUM_SUBARRAY .h"void find_maximum_subarray(){    //13,-3,-25,20,-3,-16,-23,18,20,-7,12,-5,-22,15,-4,7    vector&lt;int&gt; arr = { 13,-3,-25,20,-3,-16,-23 };    cout &lt;&lt; " array is " &lt;&lt; endl;    for (auto const&amp; i : arr)        cout &lt;&lt; i &lt;&lt; " ";    cout &lt;&lt; endl;    auto v_a = Find_Maximum_Subarray(arr, 0, arr.size()-1);    cout &lt;&lt; " Sum: " &lt;&lt; v_a[2] &lt;&lt; endl;    cout &lt;&lt; "  max subarray is " &lt;&lt; endl;    for (auto i = v_a[0];i &lt;= v_a[1];++i)        cout &lt;&lt; arr[i] &lt;&lt; " ";    cout &lt;&lt; endl;}int main(){    find_maximum_subarray();}</code></pre><!-- more -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Merge_Sort C++</title>
      <link href="/2020/10/12/merge-sort-c/"/>
      <url>/2020/10/12/merge-sort-c/</url>
      
        <content type="html"><![CDATA[<p>难点在于理解计算机执行顺序：</p><ol><li> 每次拆分(MergeSort)时，beg 和 end 的值</li><li> 每次归并(Merge)时 L，R的内容</li><li> <strong>拆分的位置 在Merge_Sort退出时，带入Merge中</strong></li></ol><p><img src="https://img-blog.csdnimg.cn/20201012175039121.png#pic_center" alt="在这里插入图片描述"><br><a href="https://www.geeksforgeeks.org/merge-sort/">执行顺序图</a><br><img src="https://img-blog.csdnimg.cn/20201012172049934.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3o5NzQ4OTA4Njk=,size_16,color_FFFFFF,t_70#pic_center"></p><p>Merge_Sort.h</p><pre><code class="cpp">#include#includevoid Merge(std::vector&lt;int&gt;&amp; A, int beg, int mid, int end) {       std::vector&lt;int&gt; L(A.cbegin() + beg, A.cbegin() + mid + 1);    std::vector&lt;int&gt; R(A.cbegin() + mid + 1, A.cbegin() + end + 1);    int i = 0, j = 0;    L.insert(L.end(), std::numeric_limits&lt;int&gt;::max());    R.insert(R.end(), std::numeric_limits&lt;int&gt;::max());    for (int k = beg; k &lt;= end; k++)     {        if (L[i] &lt; R[j])             A[k] = L[i++];        else             A[k] = R[j++];    }}void MergeSort(std::vector&lt;int&gt;&amp; A, int beg, int end) {    if (beg &lt; end)    {        int mid = beg + (end - beg) / 2;        MergeSort(A, beg, mid);        MergeSort(A, mid + 1, end);        Merge(A, beg, mid, end);    }}</code></pre><p>main.cpp</p><pre><code class="cpp">#include"Merge_Sort.h"#includeusing namespace std;int main(){    vector&lt;int&gt; arr = {38,27,43,3,9,82,10};    cout &lt;&lt; "\n array is \n";    for (auto i : arr)        cout &lt;&lt; i &lt;&lt; " ";    cout &lt;&lt; endl;        MergeSort(arr, 0, arr.size()-1);    cout &lt;&lt; "\nSorted array is \n";    for (auto i : arr)        cout &lt;&lt; i&lt;&lt;" ";    return 0;}</code></pre><!-- more -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>博客开源</title>
      <link href="/2019/08/27/blog-open-source/"/>
      <url>/2019/08/27/blog-open-source/</url>
      
        <content type="html"><![CDATA[<h1 id="效果演示"><a href="#效果演示" class="headerlink" title="效果演示"></a>效果演示</h1><p><img src="https://raw.githubusercontent.com/shw2018/cdn/master/blog_files/img/Blog-Open-Source/blog-demo1.gif" alt="演示Demo"></p><h1 id="简短介绍"><a href="#简短介绍" class="headerlink" title="简短介绍"></a>简短介绍</h1><p>倒腾了一两周总算把个人博客网站完善了，目前这个版本使用应该是够了，当然还有一些优化项和功能增加后续在慢慢更新，为了回馈开源，今天准备把我自己修改完善的<code>blog</code>网站源代码开源。这不是生成后的网页文件，是您可以直接使用的源码，您只需要把博客相关信息换成您自己的就可以部署了，对于新手或者不懂编程的小伙伴来说，简直是福音，极大简化了您构建博客的工作量和复杂度，每个人都可以下载并修改成自己喜欢样式！如果你有修改想法，欢迎PR！最后，我们还是给这个开源小项目取个名字吧，就叫<a href="https://github.com/shw2018/hexo-blog-fly.git">hexo-blog-fly</a>吧，怎么样？&lt;&lt;&lt;&lt;&lt;<a href="https://github.com/shw2018/hexo-blog-fly">源代码下载</a>&gt;&gt;&gt;&gt;&gt;</p><p>本博客基于<code>Hexo</code>框架搭建，用到<a href="https://github.com/shw2018/hexo-theme-matery">hexo-theme-matery</a>主题, 并在此基础之上做了很多修改，修复了一些bug，增加了一些新的特性和功能，博客地址：<a href="https://shw2018.github.io/">https://shw2018.github.io</a>，博客演示：<a href="https://sunhwee.com/">sunhwee.com</a>。</p><hr><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p><strong>原主题特性</strong>:</p><ul><li>简单漂亮，文章内容美观易读</li><li><a href="https://material.io/">Material Design</a> 设计</li><li>响应式设计，博客在桌面端、平板、手机等设备上均能很好的展现</li><li>首页轮播文章及每天动态切换 <code>Banner</code> 图片</li><li>瀑布流式的博客文章列表（文章无特色图片时会有 <code>24</code> 张漂亮的图片代替）</li><li>时间轴式的归档页</li><li><strong>词云</strong>的标签页和<strong>雷达图</strong>的分类页</li><li>丰富的关于我页面（包括关于我、文章统计图、我的项目、我的技能、相册等）</li><li>可自定义的数据的友情链接页面</li><li>支持文章置顶和文章打赏</li><li>支持 <code>MathJax</code></li><li><code>TOC</code> 目录</li><li>可设置复制文章内容时追加版权信息</li><li>可设置阅读文章时做密码验证</li><li><a href="https://gitalk.github.io/">Gitalk</a>、<a href="https://imsun.github.io/gitment/">Gitment</a>、<a href="https://valine.js.org/">Valine</a> 和 <a href="https://disqus.com/">Disqus</a> 评论模块（推荐使用 <code>Gitalk</code>）</li><li>集成了<a href="http://busuanzi.ibruce.info/">不蒜子统计</a>、谷歌分析（<code>Google Analytics</code>）和文章字数统计等功能</li><li>支持在首页的音乐播放和视频播放功能</li></ul><p> <strong>增加的工作或特性(未打钩的是已做但还没更新到源码的)</strong>:</p><ul><li>修改了原主题的一些很多<code>bug</code>   2019.08.05</li><li>加入图片懒加载功能，在根目录配置文件开启和关闭    2019.08.09</li><li>增加<code>留言板</code>功能          2019.08.05</li><li>在关于板块,加入<code>简历</code>功能页   2019.08.05</li><li>增加视听[视觉听觉影音]板块       2019.08.10</li><li>支持<code>emoji</code>表情，用<code>markdown emoji</code>语法书写直接生成对应的能<strong>跳跃</strong>的表情。  2019.08.10</li><li>增加网站运行时间显示  2019.08.10</li><li>增加<code>动漫模型</code>     2019.08.10</li><li>整体替换Banner图片和文章特色图片   2019.08.10</li><li>增加分类<code>相册</code>功能         2019.08.29</li><li>去掉标签页,将其合并至<code>分类</code>页中                2019.09.01</li><li>修改了一些控件的参数   2019.09.01</li><li>修改部分样式,比如: 文章卡片,固定高度,使其不至于因为文章摘要的长短不同导致卡片大小不一使页面布局很不美观,类似的还有友链卡片,优化了页面内容布局,视觉更整齐美观          2019.09.01</li><li>解决首页文章列表卡片上方 <code>border-radius</code>圆角失效的bug  2019.09.01</li><li>添加页面樱花飘落动效            2019.09.09</li><li>添加鼠标点击烟花爆炸动效   2019.09.09</li><li>加入天气接口控件   2019.09.09</li><li>加入鼠标点击文字特效   2019.09.10</li><li>添加页面雪花飘落动效            2019.09.10</li><li> 添加在线聊天插件            2019.09.12</li><li> 持续更新…</li></ul><hr><p><strong>简单使用方法：</strong></p><ol><li><code>star</code> 本项目</li><li>安装<a href="https://git-scm.com/downloads">Git</a>, 安装<a href="https://nodejs.org/en/">nodeJS</a></li><li>你可以直接<code>fork</code>一份源码到你的仓库，<code>clone</code>到本地</li><li>在本地博客仓库运行<code>npm i</code>命令安装依赖包</li><li>修改配置信息，改成自己的信息</li><li>运行命令<code>hexo  clean</code>（清除生成文件），<code>hexo g</code>（生成网页）， <code>hexo  s</code>（本地预览），<code>hexo d</code>（部署）</li></ol><blockquote><p><strong>更多详情教程，强烈推荐看我写的：<a href="https://sunhwee.com/posts/6e8839eb.html">Hexo+Github博客搭建完全教程</a></strong></p></blockquote><blockquote><p><strong>最后，如果项目和教程对你有所帮助或者你看见了还算比较喜欢，欢迎给我<code>star</code>，谢谢您！</strong></p></blockquote><p><strong>持续更新中…，如果遇到问题欢迎联系我，在文章最后评论区【留言和讨论】，当然，欢迎点击文章最后的打赏按键，请博主一杯冰阔乐，笑～</strong><br><escape></escape></p><table>  <tbody><tr>    <td><img width="100" src="https://sunhwee.com/medias/reward/alipay.bmp"></td>    <td><img width="100" src="https://sunhwee.com/medias/reward/wechat.bmp"></td>    <td><img width="100" src="https://sunhwee.com/medias/reward/zan.png"></td>     </tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 软件安装与配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Github </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
